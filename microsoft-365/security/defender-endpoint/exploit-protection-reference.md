---
title: Exploit protection 參考
keywords: 緩解、弱點、弱點、緩解、利用、利用、emet
description: 如何在 Windows 10 中運作 exploit protection 功能的詳細資料
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: a87215b0e23d56a73259bbee4600ec9e15a27f3b
ms.sourcegitcommit: dcb97fbfdae52960ae62b6faa707a05358193ed5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/25/2021
ms.locfileid: "51199342"
---
# <a name="exploit-protection-reference"></a><span data-ttu-id="d4c8e-104">Exploit Protection 參考</span><span class="sxs-lookup"><span data-stu-id="d4c8e-104">Exploit Protection Reference</span></span>

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


<span data-ttu-id="d4c8e-105">**適用於：**</span><span class="sxs-lookup"><span data-stu-id="d4c8e-105">**Applies to:**</span></span>
- [<span data-ttu-id="d4c8e-106">適用於端點的 Microsoft Defender</span><span class="sxs-lookup"><span data-stu-id="d4c8e-106">Microsoft Defender for Endpoint</span></span>](https://go.microsoft.com/fwlink/?linkid=2154037)
- [<span data-ttu-id="d4c8e-107">Microsoft 365 Defender</span><span class="sxs-lookup"><span data-stu-id="d4c8e-107">Microsoft 365 Defender</span></span>](https://go.microsoft.com/fwlink/?linkid=2118804)

><span data-ttu-id="d4c8e-108">想要體驗 Microsoft Defender for Endpoint？</span><span class="sxs-lookup"><span data-stu-id="d4c8e-108">Want to experience Microsoft Defender for Endpoint?</span></span> [<span data-ttu-id="d4c8e-109">註冊免費試用版。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-109">Sign up for a free trial.</span></span>](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

<span data-ttu-id="d4c8e-110">Exploit protection 為 IT 專業人員在編譯及散佈軟體之後可以套用的應用程式提供高級保護。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-110">Exploit protection provides advanced protections for applications that the IT Pro can apply after the developer has compiled and distributed the software.</span></span>

<span data-ttu-id="d4c8e-111">本文可協助您瞭解如何在原則層級和個別的緩解原則上進行 exploit protection 的運作，以協助您成功建立及套用 Exploit Protection 原則。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-111">This article helps you understand how exploit protection works, both at the policy level and at the individual mitigation level, to help you successfully build and apply Exploit Protection policies.</span></span>

## <a name="how-mitigations-are-applied"></a><span data-ttu-id="d4c8e-112">如何套用緩解</span><span class="sxs-lookup"><span data-stu-id="d4c8e-112">How mitigations are applied</span></span>

<span data-ttu-id="d4c8e-113">每個應用程式都會套用 Exploit Protection 緩解。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-113">Exploit Protection mitigations are applied per application.</span></span>

<span data-ttu-id="d4c8e-114">針對您為其設定保護的每個程式，透過登錄專案設定緩解。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-114">Mitigations are configured via a registry entry for each program that you configure protections for.</span></span> <span data-ttu-id="d4c8e-115">這些設定儲存在每個程式 (的 **MitigationOptions** 登錄專案中 **HKEY_LOCAL_MACHINE \ 軟體 \ MICROSOFT \ Windows NT \ CurrentVersion \ 映射檔執行選項 \ *ImageFileName* \ MitigationOptions**) 。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-115">These settings are stored in the **MitigationOptions** registry entry for each program (**HKEY_LOCAL_MACHINE \ SOFTWARE \ Microsoft \ Windows NT \ CurrentVersion \ Image File Execution Options \ *ImageFileName* \ MitigationOptions**).</span></span> <span data-ttu-id="d4c8e-116">它們會在您重新開機程式時生效，而且在您變更並重新啟動程式之前仍然有效。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-116">They take effect when you restart the program and remain effective until you change them and restart the program again.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="d4c8e-117">Image File 執行選項僅允許您指定檔案名或路徑，而不是版本號碼、架構或任何其他特異點。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-117">Image File Execution Options only allows you to specify a file name or path, and not a version number, architecture, or any other differentiator.</span></span> <span data-ttu-id="d4c8e-118">請務必將遷移目標設定為具有唯一名稱或路徑的應用程式，只在您已測試該版本的裝置及該應用程式的架構上加以套用。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-118">Be careful to target mitigations to apps which have unique names or paths, applying them only on devices where you have tested that version and that architecture of the application.</span></span>

<span data-ttu-id="d4c8e-119">如果您使用 XML 設定檔（不論是透過 PowerShell、群組原則或 MDM）設定 exploit protection 緩解，請在處理此 XML 設定檔時，為您設定個別的登錄設定。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-119">If you configure exploit protection mitigations using an XML configuration file, either via PowerShell, Group Policy, or MDM, when processing this XML configuration file, individual registry settings will be configured for you.</span></span>

<span data-ttu-id="d4c8e-120">當您不再強制發佈 XML 檔案時，不會自動移除由此 XML 設定檔部署的設定。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-120">When the policy distributing the XML file is no longer enforced, settings deployed by this XML configuration file will not be automatically removed.</span></span> <span data-ttu-id="d4c8e-121">若要移除 Exploit Protection 設定，請從全新 Windows 10 裝置匯出 XML 設定，然後部署此新的 XML 檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-121">To remove Exploit Protection settings, export the XML configuration from a clean Windows 10 device, and deploy this new XML file.</span></span> <span data-ttu-id="d4c8e-122">另外，Microsoft 也會提供 XML 檔案作為 Windows 安全性基準的一部分，以重設 Exploit Protection 設定。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-122">Alternately, Microsoft provides an XML file as part of the Windows Security Baselines for resetting Exploit Protection settings.</span></span>

<span data-ttu-id="d4c8e-123">若要使用 PowerShell 重設 exploit protection 設定，您可以使用下列命令：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-123">To reset exploit protection settings using PowerShell, you could use the following command:</span></span>

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
<span data-ttu-id="d4c8e-124">以下是與 Windows 安全性基準一起發佈的 EP-reset.xml：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-124">Following is the EP-reset.xml distributed with the Windows Security Baselines:</span></span>
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a><span data-ttu-id="d4c8e-125">緩解參照</span><span class="sxs-lookup"><span data-stu-id="d4c8e-125">Mitigation Reference</span></span>

<span data-ttu-id="d4c8e-126">下列各節將詳細說明每項 exploit protection 緩解措施所提供的保護、緩解的相容性考慮，以及可用的設定選項。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-126">The following sections detail the protections provided by each exploit protection mitigation, the compatibility considerations for the mitigation, and the configuration options available.</span></span>

## <a name="arbitrary-code-guard"></a><span data-ttu-id="d4c8e-127">任意代碼保護</span><span class="sxs-lookup"><span data-stu-id="d4c8e-127">Arbitrary code guard</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-128">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-128">Description</span></span>

<span data-ttu-id="d4c8e-129">任意代碼保護措施可協助防範惡意攻擊者，透過記憶體安全弱點將其選擇的程式碼載入到記憶體中，並能夠執行該程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-129">Arbitrary code guard helps protect against a malicious attacker loading the code of their choice into memory through a memory safety vulnerability and being able to execute that code.</span></span>

<span data-ttu-id="d4c8e-130">任意代碼保護會保護應用程式無法執行動態產生的程式碼 (未載入的程式碼，例如從 exe 本身或 dll) 。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-130">Arbitrary code guard protects an application from executing dynamically generated code (code that is not loaded, for example, from the exe itself or a dll).</span></span> <span data-ttu-id="d4c8e-131">使用任何程式碼 guard，都可以避免將記憶體標示為可執行。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-131">Arbitrary code guard works by preventing memory from being marked as executable.</span></span> <span data-ttu-id="d4c8e-132">當應用程式嘗試 [分配記憶體](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)時，我們會檢查保護旗標。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-132">When an application attempts to [allocate memory](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc), we check the protection flags.</span></span> <span data-ttu-id="d4c8e-133"> (記憶體可使用讀取、寫入和/或執行保護旗標進行指派。 ) 如果分配嘗試包含 [*執行*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) 保護旗標，則記憶體分配會失敗，並傳回錯誤碼 (STATUS_DYNAMIC_CODE_BLOCKED) 。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-133">(Memory can be allocated with read, write, and/or execute protection flags.) If the allocation attempts to include the [*execute*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) protection flag, then the memory allocation fails and returns an error code (STATUS_DYNAMIC_CODE_BLOCKED).</span></span> <span data-ttu-id="d4c8e-134">同樣地，如果應用程式嘗試變更已分配的 [記憶體保護旗標](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) ，並包含 [*執行*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) 保護旗標，則許可權變更會失敗並傳回錯誤碼 (STATUS_DYNAMIC_CODE_BLOCKED) 。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-134">Similarly, if an application attempts to [change the protection flags of memory](https://docs.microsoft.com/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) that has already been allocated and includes the [*execute*](https://docs.microsoft.com/windows/win32/memory/memory-protection-constants) protection flag, then the permission change fails and returns an error code (STATUS_DYNAMIC_CODE_BLOCKED).</span></span>

<span data-ttu-id="d4c8e-135">透過禁止設定 [ *執行* ] 旗標，Windows 10 的資料執行防護功能就可以避免將指令指標設定為該記憶體並執行該程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-135">By preventing the *execute* flag from being set, the data execution prevention feature of Windows 10 can then protect against the instruction pointer being set to that memory and running that code.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-136">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-136">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-137">任意代碼保護可防止將任何記憶體當做可執行檔方式來分配，這會帶來即時 (JIT) 編譯器等方法的相容性問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-137">Arbitrary code guard prevents allocating any memory as executable, which presents a compatibility issue with approaches such as Just-in-Time (JIT) compilers.</span></span> <span data-ttu-id="d4c8e-138">例如，大多數新式瀏覽器都會將 JavaScript 編譯成原生程式碼，以優化效能。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-138">Most modern browsers, for example, will compile JavaScript into native code in order to optimize performance.</span></span> <span data-ttu-id="d4c8e-139">為了支援此項緩解，您需要 rearchitected 以在受保護的程式外移動 JIT 編譯。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-139">In order to support this mitigation, they will need to be rearchitected to move the JIT compilation outside of the protected process.</span></span> <span data-ttu-id="d4c8e-140">其他應用程式，其設計可從腳本或其他中間語言產生程式碼會類似于此緩解。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-140">Other applications whose design dynamically generates code from scripts or other intermediate languages will be similarly incompatible with this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-141">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-141">Configuration options</span></span>

<span data-ttu-id="d4c8e-142">**允許執行緒自願** 使用-您可以設定緩解，以允許個別執行緒自願退出這項保護。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-142">**Allow thread opt-out** - You can configure the mitigation to allow an individual thread to opt-out of this protection.</span></span> <span data-ttu-id="d4c8e-143">開發人員必須已編寫應用程式，且已將 *ThreadInformation* 參數設定為 **ThreadDynamicCodePolicy** ， [](https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation)才能允許在此執行緒上執行動態程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-143">The developer must have written the application with awareness of this mitigation, and have called the [**SetThreadInformation**](https://docs.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation) API with the *ThreadInformation* parameter set to **ThreadDynamicCodePolicy** in order to be allowed to execute dynamic code on this thread.</span></span>

<span data-ttu-id="d4c8e-144">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-144">**Audit only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-145">然後可以在事件檢視器中查看或使用 [Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-145">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="block-low-integrity-images"></a><span data-ttu-id="d4c8e-146">封鎖低誠信影像</span><span class="sxs-lookup"><span data-stu-id="d4c8e-146">Block low integrity images</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-147">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-147">Description</span></span>

<span data-ttu-id="d4c8e-148">封鎖低誠信影像可防止應用程式載入不受信任的檔案，通常是因為這些檔案已從沙箱瀏覽器從網際網路下載。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-148">Block low integrity images prevents the application from loading files that are untrusted, typically because they have been downloaded from the internet from a sandboxed browser.</span></span>

<span data-ttu-id="d4c8e-149">如果此圖像有 (ACE) 會授與低 IL 處理常式的存取權，且沒有信任標籤 ACE，則此緩解會封鎖圖像載入。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-149">This mitigation will block image loads if the image has an Access Control Entry (ACE) which grants access to Low IL processes and which does not have a trust label ACE.</span></span> <span data-ttu-id="d4c8e-150">它是由記憶體管理員所實施，它會封鎖檔案不會被對應至記憶體。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-150">It is implemented by the memory manager, which blocks the file from being mapped into memory.</span></span> <span data-ttu-id="d4c8e-151">如果應用程式嘗試對應低完整性影像，它會觸發 STATUS_ACCESS_DENIED 錯誤。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-151">If an application attempts to map a low integrity image, it will trigger a STATUS_ACCESS_DENIED error.</span></span> <span data-ttu-id="d4c8e-152">如需完整性層級運作方式的詳細資訊，請參閱 [必要的完整性控制](https://docs.microsoft.com/windows/win32/secauthz/mandatory-integrity-control)。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-152">For details on how integrity levels work, see [Mandatory Integrity Control](https://docs.microsoft.com/windows/win32/secauthz/mandatory-integrity-control).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-153">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-153">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-154">封鎖低誠信影像會使應用程式無法載入從網際網路下載的檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-154">Block low integrity images will prevent the application from loading files that were downloaded from the internet.</span></span> <span data-ttu-id="d4c8e-155">如果您的應用程式工作流程需要載入已下載的影像，您會想要確保從較高信任的程式下載，或明確重新標記它們，以便套用此項緩解。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-155">If your application workflow requires loading images that are downloaded, you will want to ensure that they are downloaded from a higher-trust process, or are explicitly relabeled in order to apply this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-156">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-156">Configuration options</span></span>

<span data-ttu-id="d4c8e-157">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-157">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-158">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-158">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="block-remote-images"></a><span data-ttu-id="d4c8e-159">封鎖遠端映射</span><span class="sxs-lookup"><span data-stu-id="d4c8e-159">Block remote images</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-160">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-160">Description</span></span>

<span data-ttu-id="d4c8e-161">封鎖遠端映射有助於防止應用程式載入遠端裝置上主控的檔案，例如 UNC 共用。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-161">Blocking remote images helps to prevent the application from loading files that are hosted on a remote device, such as a UNC share.</span></span> <span data-ttu-id="d4c8e-162">封鎖遠端映射可協助防止將二進位檔案載入到攻擊者所控制的外部裝置的記憶體中。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-162">Blocking remote images helps protect against loading binaries into memory that are on an external device controlled by the attacker.</span></span>

<span data-ttu-id="d4c8e-163">如果將影像決定在遠端裝置上，此緩解會封鎖圖像載入。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-163">This mitigation will block image loads if the image is determined to be on a remote device.</span></span> <span data-ttu-id="d4c8e-164">它是由記憶體管理員所實施，它會封鎖檔案不會被對應至記憶體。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-164">It is implemented by the memory manager, which blocks the file from being mapped into memory.</span></span> <span data-ttu-id="d4c8e-165">如果應用程式嘗試對應遠端檔案，則會觸發 STATUS_ACCESS_DENIED 錯誤。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-165">If an application attempts to map a remote file, it will trigger a STATUS_ACCESS_DENIED error.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-166">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-166">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-167">封鎖遠端映射會使應用程式無法從遠端裝置載入影像。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-167">Block remote images will prevent the application from loading images from remote devices.</span></span> <span data-ttu-id="d4c8e-168">如果您的應用程式從遠端裝置載入檔案或外掛程式，它將不會與此項緩解相容。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-168">If your application loads files or plug-ins from remote devices, then it will not be compatible with this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-169">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-169">Configuration options</span></span>

<span data-ttu-id="d4c8e-170">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-170">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-171">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-171">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="block-untrusted-fonts"></a><span data-ttu-id="d4c8e-172">封鎖不受信任的字體</span><span class="sxs-lookup"><span data-stu-id="d4c8e-172">Block untrusted fonts</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-173">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-173">Description</span></span>

<span data-ttu-id="d4c8e-174">封鎖不受信任的字型可降低因導致攻擊者能夠在裝置上執行程式碼的字型剖析中的缺陷風險。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-174">Block untrusted fonts mitigates the risk of a flaw in font parsing leading to the attacker being able to run code on the device.</span></span> <span data-ttu-id="d4c8e-175">只會載入安裝在 windows\fonts 目錄中的字體，以供 GDI 處理。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-175">Only fonts that are installed into the windows\fonts directory will be loaded for processing by GDI.</span></span>

<span data-ttu-id="d4c8e-176">這項緩解是在 GDI 中實施，這會驗證檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-176">This mitigation is implemented within GDI, which validates the location of the file.</span></span> <span data-ttu-id="d4c8e-177">如果檔案不在系統字型目錄中，則不會載入字型以進行剖析，而且此呼叫會失敗。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-177">If the file is not in the system fonts directory, the font will not be loaded for parsing and that call will fail.</span></span>

<span data-ttu-id="d4c8e-178">此項緩解是除了 Windows 10 1607 和更新版本中所提供的內建的緩解，也會將字體分析移出內核，並移至使用者模式應用程式容器。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-178">This mitigation is in addition to the built-in mitigation provided in Windows 10 1607 and later, which moves font parsing out of the kernel and into a user-mode app container.</span></span> <span data-ttu-id="d4c8e-179">以字體分析為基礎的任何利用方式，都是在沙箱化且隔離的內容中進行，這樣會大幅降低風險。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-179">Any exploit based on font parsing, as a result, happens in a sandboxed and isolated context, which reduces the risk significantly.</span></span> <span data-ttu-id="d4c8e-180">如需此緩解的詳細資訊，請參閱博客 [強化 Windows 10 和零日利用方式緩解](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-180">For details on this mitigation, see the blog [Hardening Windows 10 with zero-day exploit mitigations](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-181">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-181">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-182">在 [系統字體] 目錄外，最常用的字型是使用 [web](https://docs.microsoft.com/typography/fonts/font-faq#web)字型。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-182">The most common use of fonts outside of the system fonts directory is with [web fonts](https://docs.microsoft.com/typography/fonts/font-faq#web).</span></span> <span data-ttu-id="d4c8e-183">新式瀏覽器（例如 Microsoft Edge）使用 DirectWrite，而不是 GDI，而且不會受到影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-183">Modern browsers, such as Microsoft Edge, use DirectWrite instead of GDI, and are not impacted.</span></span> <span data-ttu-id="d4c8e-184">不過，舊版瀏覽器（如 Office 365) 的 Internet Explorer 11 (和 IE 模式）可能會受到影響，尤其是使用字型字型來顯示 UI 的應用程式（例如 Office）。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-184">However, legacy browsers, such as Internet Explorer 11 (and IE mode in the new Microsoft Edge) can be impacted, particularly with applications such as Office 365, which use font glyphs to display UI.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-185">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-185">Configuration options</span></span>

<span data-ttu-id="d4c8e-186">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-186">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-187">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-187">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="code-integrity-guard"></a><span data-ttu-id="d4c8e-188">程式碼整體性防護</span><span class="sxs-lookup"><span data-stu-id="d4c8e-188">Code integrity guard</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-189">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-189">Description</span></span>

<span data-ttu-id="d4c8e-190">程式碼完整性保護可確保所有載入到程式中的二進位檔案都由 Microsoft 進行數位簽章。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-190">Code integrity guard ensures that all binaries loaded into a process are digitally signed by Microsoft.</span></span> <span data-ttu-id="d4c8e-191">程式碼整體性防護包括 [whql](https://docs.microsoft.com/windows-hardware/drivers/install/whql-release-signature) (Windows 硬體品質實驗室) 簽章，可讓 whql 核准的驅動程式在程式中執行。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-191">Code integrity guard includes [WHQL](https://docs.microsoft.com/windows-hardware/drivers/install/whql-release-signature) (Windows Hardware Quality Labs) signatures, which will allow WHQL-approved drivers to run within the process.</span></span>

<span data-ttu-id="d4c8e-192">這種緩解是在記憶體管理員內實施，這會封鎖二進位數以對應至記憶體。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-192">This mitigation is implemented within the memory manager, which blocks the binary from being mapped into memory.</span></span> <span data-ttu-id="d4c8e-193">如果您嘗試載入的二進位檔案未由 Microsoft 簽署，記憶體管理器將會傳回錯誤 STATUS_INVALID_IMAGE_HASH。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-193">If you attempt to load a binary that is not signed by Microsoft, the memory manger will return the error STATUS_INVALID_IMAGE_HASH.</span></span> <span data-ttu-id="d4c8e-194">透過在記憶體管理員層級封鎖，可防止處理常式和二進位檔案所載入的二進位檔案都被插入處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-194">By blocking at the memory manager level, this prevents both binaries loaded by the process and binaries injected into the process.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-195">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-195">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-196">這種緩解特別會封鎖未由 Microsoft 簽署的任何二進位檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-196">This mitigation specifically blocks any binary that is not signed by Microsoft.</span></span> <span data-ttu-id="d4c8e-197">如此一來，它就會與大多數協力廠商軟體不相容，除非軟體是透過) Microsoft Store (和數位簽署方式發佈，而且會選取允許載入 Microsoft Store 所簽署之影像的選項。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-197">As such, it will be incompatible with most third-party software, unless that software is distributed by (and digitally signed by) the Microsoft Store, and the option to allow loading of images signed by the Microsoft Store is selected.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-198">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-198">Configuration options</span></span>

<span data-ttu-id="d4c8e-199">**此外，允許載入** microsoft store 所簽署之應用程式所簽署的影像，將由 microsoft store 以數位方式簽署，新增此設定將允許應用程式載入已透過 Store 認證程式進行的二進位檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-199">**Also allow loading of images signed by Microsoft Store** - Applications that are distributed by the Microsoft Store will be digitally signed by the Microsoft Store, and adding this configuration will allow binaries that have gone through the store certification process to be loaded by the application.</span></span>

<span data-ttu-id="d4c8e-200">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-200">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-201">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-201">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="control-flow-guard-cfg"></a><span data-ttu-id="d4c8e-202">控制流量防護 (CFG) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-202">Control flow guard (CFG)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-203">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-203">Description</span></span>

<span data-ttu-id="d4c8e-204">控制流量防護 (CFG) 會保護間接的函數呼叫，以降低攻擊者使用記憶體損毀漏洞的風險。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-204">Control flow guard (CFG) mitigates the risk of attackers using memory corruption vulnerabilities by protecting indirect function calls.</span></span> <span data-ttu-id="d4c8e-205">例如，攻擊者可能會使用緩衝區溢位弱點覆寫包含函數指標的記憶體，並以指標取代該函數指標，其選擇的可執行程式碼也 (，也就是插入程式) 中。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-205">For example, an attacker may user a buffer overflow vulnerability to overwrite memory containing a function pointer, and replace that function pointer with a pointer to executable code of their choice (which may also have been injected into the program).</span></span>

<span data-ttu-id="d4c8e-206">在編譯時間插入另一個檢查即可提供此緩解。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-206">This mitigation is provided by injecting another check at compile time.</span></span> <span data-ttu-id="d4c8e-207">在每個間接功能呼叫之前，新增另一個指示，以確認目標是有效的呼叫目標，再呼叫它。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-207">Before each indirect function call, another instructions are added which verify that the target is a valid call target before it is called.</span></span> <span data-ttu-id="d4c8e-208">若目標不是有效的呼叫目標，則應用程式會終止。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-208">If the target is not a valid call target, then the application is terminated.</span></span> <span data-ttu-id="d4c8e-209">如此一來，只有以 CFG 所支援的應用程式，才能受益于此緩解。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-209">As such, only applications that are compiled with CFG support can benefit from this mitigation.</span></span>

<span data-ttu-id="d4c8e-210">Windows 內核會提供有效目標的檢查。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-210">The check for a valid target is provided by the Windows kernel.</span></span> <span data-ttu-id="d4c8e-211">當載入可執行檔時，間接呼叫目標的中繼資料會在載入時解壓縮，並標示為有效的呼叫目標。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-211">When executable files are loaded, the metadata for indirect call targets is extracted at load time and marked as valid call targets.</span></span> <span data-ttu-id="d4c8e-212">此外，記憶體的指派及標示為可執行檔 (例如，針對產生的程式碼) ，這些記憶體位置也會標示為有效的呼叫目標，以支援 JIT 編譯等機制。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-212">Additionally, when memory is allocated and marked as executable (such as for generated code), these memory locations are also marked as valid call targets, to support mechanisms such as JIT compilation.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-213">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-213">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-214">因為應用程式必須編譯以支援 CFG，所以它們會以隱含方式宣告其相容性。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-214">Since applications must be compiled to support CFG, they implicitly declare their compatibility with it.</span></span> <span data-ttu-id="d4c8e-215">因此，大多數的應用程式都應該在啟用此緩解的情況下運作。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-215">Most applications, therefore, should work with this mitigation enabled.</span></span> <span data-ttu-id="d4c8e-216">因為這些檢查會編譯成二進位，您可以套用的設定只會停用 Windows 內核中的檢查。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-216">Because these checks are compiled into the binary, the configuration you can apply is merely to disable checks within the Windows kernel.</span></span> <span data-ttu-id="d4c8e-217">換句話說，依預設會開啟緩解，但您可以將 Windows 內核設定為在您稍後判斷應用程式開發人員在其測試中未發現的相容性問題（應該很少見）時，永遠傳回「是」。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-217">In other words, the mitigation is on by default, but you can configure the Windows kernel to always return "yes" if you later determine that there is a compatibility issue that the application developer did not discover in their testing, which should be rare.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-218">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-218">Configuration options</span></span>

<span data-ttu-id="d4c8e-219">**使用 STRICT CFG** -在嚴格模式中，載入到程式中的所有二進位檔案都必須編譯以進行控制流程防護 (，否則不會包含任何可執行程式碼（例如資源 dll) 以供載入）。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-219">**Use strict CFG** - In strict mode, all binaries loaded into the process must be compiled for Control Flow Guard (or have no executable code in them - such as resource dlls) in order to be loaded.</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-220">**控制流量防護** 沒有任何審計模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-220">**Control flow guard** has no audit mode.</span></span> <span data-ttu-id="d4c8e-221">二進位檔案會在啟用此緩解功能時進行編譯。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-221">Binaries are compiled with this mitigation enabled.</span></span>

## <a name="data-execution-prevention-dep"></a><span data-ttu-id="d4c8e-222">資料執行防護 (DEP) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-222">Data Execution Prevention (DEP)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-223">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-223">Description</span></span>

<span data-ttu-id="d4c8e-224">資料執行防護 (DEP) 會防止未明確指派成可執行檔記憶體執行。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-224">Data execution prevention (DEP) prevents memory that was not explicitly allocated as executable from being executed.</span></span> <span data-ttu-id="d4c8e-225">DEP 可協助防範攻擊者將惡意程式碼注入程式中，例如透過緩衝區溢位，然後執行該程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-225">DEP helps protect against an attacker injecting malicious code into the process, such as through a buffer overflow, and then executing that code.</span></span>

<span data-ttu-id="d4c8e-226">如果您嘗試將指令指標設定為未標示為可執行檔記憶體位址，處理器會引發例外狀況 (一般保護違例) ，導致應用程式當機。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-226">If you attempt to set the instruction pointer to a memory address not marked as executable, the processor will throw an exception (general-protection violation), causing the application to crash.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-227">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-227">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-228">所有 x64、ARM 及 ARM-64 可執行檔預設都會啟用 DEP，而且無法停用。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-228">All x64, ARM, and ARM-64 executables have DEP enabled by default, and it cannot be disabled.</span></span> <span data-ttu-id="d4c8e-229">因為應用程式永遠不會執行 DEP，所以會採用相容性。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-229">Since an application will have never been executed without DEP, compatibility is assumed.</span></span>

<span data-ttu-id="d4c8e-230">所有 x86 (32 位) 二進位檔案預設都會啟用 DEP，但可對每個進程停用 DEP。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-230">All x86 (32-bit) binaries have DEP enabled by default, but DEP can be disabled per process.</span></span> <span data-ttu-id="d4c8e-231">一些舊的繼承應用程式（通常是在 Windows XP SP2 之前所開發的應用程式）可能無法與 DEP 相容。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-231">Some old legacy applications, typically applications developed prior to Windows XP SP2, might not be compatible with DEP.</span></span> <span data-ttu-id="d4c8e-232">這類應用程式通常會以動態方式產生程式碼 (例如，JIT 編譯) 或連結到舊的文件庫 (例如，) 可動態產生程式碼的舊版 ATL。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-232">Such applications typically generate code dynamically (for example, JIT compiling) or link to older libraries (such as older versions of ATL) which dynamically generate code.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-233">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-233">Configuration options</span></span>

<span data-ttu-id="d4c8e-234">**啟用 Atl Thunk 模擬** -此設定選項會停用 ATL Thunk 模擬。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-234">**Enable ATL Thunk emulation** - This configuration option disables ATL Thunk emulation.</span></span> <span data-ttu-id="d4c8e-235">ATL （ActiveX 範本庫）的設計方式，都是盡可能快又快。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-235">ATL, the ActiveX Template Library, is designed to be as small and fast as possible.</span></span> <span data-ttu-id="d4c8e-236">為了降低二進位大小，它會使用稱為 *Thunking* 的技術。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-236">In order to reduce binary size, it would use a technique called *thunking*.</span></span> <span data-ttu-id="d4c8e-237">Thunking 通常會考慮在32位和16位的應用程式之間進行互動，但沒有任何16位的元件可以在 ATL 上進行。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-237">Thunking is typically thought of for interacting between 32-bit and 16-bit applications, but there are no 16-bit components to ATL here.</span></span> <span data-ttu-id="d4c8e-238">相反地，為了針對二進位大小進行優化，ATL 會將機器碼儲存在非文字對齊 (的記憶體中，以建立較小的二進位) ，然後直接叫用該程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-238">Rather, in order to optimize for binary size, ATL will store machine code in memory that is not word-aligned (creating a smaller binary), and then invoke that code directly.</span></span> <span data-ttu-id="d4c8e-239">使用 Visual Studio 7.1 或更早版本編譯的 ATL 元件 (Visual Studio 2003) 請勿將此記憶體配置為可執行檔 Thunk 模擬，以消除相容性問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-239">ATL components compiled with Visual Studio 7.1 or earlier (Visual Studio 2003) do not allocate this memory as executable - thunk emulation resolves that compatibility issue.</span></span> <span data-ttu-id="d4c8e-240">具有二進位擴充模型 (的應用程式（例如 Internet Explorer 11) ）通常必須啟用 ATL Thunk 模擬。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-240">Applications that have a binary extension model (such as Internet Explorer 11) will often need to have ATL Thunk emulation enabled.</span></span>

## <a name="disable-extension-points"></a><span data-ttu-id="d4c8e-241">停用分機點</span><span class="sxs-lookup"><span data-stu-id="d4c8e-241">Disable extension points</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-242">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-242">Description</span></span>

<span data-ttu-id="d4c8e-243">此項緩解會停用應用程式的各種擴充點，可用來建立持久性或提升惡意內容的許可權。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-243">This mitigation disables various extension points for an application, which might be used to establish persistence or elevate privileges of malicious content.</span></span>

<span data-ttu-id="d4c8e-244">這包括：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-244">This includes:</span></span>

- <span data-ttu-id="d4c8e-245">**AppInit dll** -每當處理常式啟動時，系統會將指定的 DLL 載入到新啟動程式的內容中，再呼叫其進入點函數。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-245">**AppInit DLLs** - Whenever a process starts, the system will load the specified DLL into to context of the newly started process before calling its entry point function.</span></span> <span data-ttu-id="d4c8e-246">您[可以在這裡找到 AppInit dll 的詳細資料](https://docs.microsoft.com/windows/win32/winmsg/about-window-classes#application-global-classes)。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-246">[Details on AppInit DLLs can be found here](https://docs.microsoft.com/windows/win32/winmsg/about-window-classes#application-global-classes).</span></span> <span data-ttu-id="d4c8e-247">套用此緩解原則時，不會載入 AppInit Dll。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-247">With this mitigation applied, AppInit DLLs are not loaded.</span></span> <span data-ttu-id="d4c8e-248">從 Windows 7 開始，AppInit Dll 必須進行數位簽章， [如下所述](https://docs.microsoft.com/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2)。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-248">Beginning with Windows 7, AppInit DLLs need to be digitally signed, [as described here](https://docs.microsoft.com/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2).</span></span> <span data-ttu-id="d4c8e-249">此外，如果啟用 SecureBoot，將不會載入 AppInit Dll （ [如這裡所述](https://docs.microsoft.com/windows/win32/dlls/secure-boot-and-appinit-dlls)）。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-249">Additionally, beginning with Windows 8, AppInit DLLs will not be loaded if SecureBoot is enabled, [as described here](https://docs.microsoft.com/windows/win32/dlls/secure-boot-and-appinit-dlls).</span></span>
- <span data-ttu-id="d4c8e-250">**舊版** 輸入法-輸入法編輯器 (輸入法) 可讓使用者輸入的文字的語言超過可以在鍵盤上呈現的字元數。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-250">**Legacy IMEs** - An Input Method Editor (IME) allows a user to type text in a language that has more characters than can be represented on a keyboard.</span></span> <span data-ttu-id="d4c8e-251">協力廠商可以建立 Ime。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-251">Third parties are able to create IMEs.</span></span> <span data-ttu-id="d4c8e-252">惡意的輸入法可能會取得來自此輸入捕獲的認證或其他敏感資訊。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-252">A malicious IME might obtain credentials or other sensitive information from this input capture.</span></span> <span data-ttu-id="d4c8e-253">有些 Ime （稱為舊版 Ime）只會在 Windows 桌面應用程式上運作，而不能在 UWP 應用程式上運作。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-253">Some IMEs, referred to as Legacy IMEs, will only work on Windows Desktop apps, and not UWP apps.</span></span> <span data-ttu-id="d4c8e-254">這種緩解也會防止舊版 IME 載入指定的 Windows 桌面應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-254">This mitigation will also prevent this legacy IME from loading into the specified Windows Desktop app.</span></span>
- <span data-ttu-id="d4c8e-255">**Windows 事件掛接** -應用程式可呼叫 [SetWinEventHook API](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook) ，以在發生事件時註冊利益。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-255">**Windows Event Hooks** - An application can call the [SetWinEventHook API](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-setwineventhook) to register interest in an event taking place.</span></span> <span data-ttu-id="d4c8e-256">會指定 DLL，並可將其注入程式中。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-256">A DLL is specified and can be injected into the process.</span></span> <span data-ttu-id="d4c8e-257">此項減輕會強制將掛接傳送至註冊程式，而不是透過插入的 DLL 在進程內執行。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-257">This mitigation forces the hook to be posted to the registering process rather than running in-process through an injected DLL.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-258">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-258">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-259">大部分的延伸點都相對較少使用，所以相容性影響通常很小，尤其是在個別應用層級。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-259">Most of these extension points are relatively infrequently used, so compatibility impact is typically small, particularly at an individual application level.</span></span> <span data-ttu-id="d4c8e-260">考慮的是，如果使用者使用協力廠商的舊版 Ime，將無法與受保護的應用程式搭配使用。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-260">The one consideration is if users are using third-party Legacy IMEs that will not work with the protected application.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-261">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-261">Configuration options</span></span>

<span data-ttu-id="d4c8e-262">此項緩解沒有任何設定選項。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-262">There are no configuration options for this mitigation.</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-263">**停用分機點** 沒有審計模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-263">**Disable extension points** has no audit mode.</span></span>

## <a name="disable-win32k-system-calls"></a><span data-ttu-id="d4c8e-264">停用 Win32k 系統通話</span><span class="sxs-lookup"><span data-stu-id="d4c8e-264">Disable Win32k system calls</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-265">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-265">Description</span></span>

<span data-ttu-id="d4c8e-266">Win32k.sys 提供攻擊者廣泛的攻擊面。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-266">Win32k.sys provides a broad attack surface for an attacker.</span></span> <span data-ttu-id="d4c8e-267">做為核心模式元件時，它通常會以沙箱化應用程式的轉義向量為目標。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-267">As a kernel-mode component, it is frequently targeted as an escape vector for applications that are sandboxed.</span></span> <span data-ttu-id="d4c8e-268">這種緩解功能會封鎖執行緒，以防止呼叫 win32k.sys，其方式是封鎖執行緒，以將其自身轉換成 GUI 執行緒，然後就可以存取權調用 Win32k 函數。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-268">This mitigation prevents calls into win32k.sys by blocking a thread from converting itself into a GUI thread, which is then given access to invoke Win32k functions.</span></span> <span data-ttu-id="d4c8e-269">在建立時，執行緒是非 GUI，但會在第一次呼叫 win32k.sys 時，或透過 API 對 [IsGuiThread](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-isguithread)進行轉換。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-269">A thread is non-GUI when created, but converted on first call to win32k.sys, or through an API call to [IsGuiThread](https://docs.microsoft.com/windows/win32/api/winuser/nf-winuser-isguithread).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-270">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-270">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-271">這種緩解方式是針對專用非 UI 進程的處理常式而設計。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-271">This mitigation is designed for processes that are dedicated non-UI processes.</span></span> <span data-ttu-id="d4c8e-272">例如，許多新式瀏覽器都會使用進程隔離，並併入非 UI 進程。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-272">For example, many modern browsers will use process isolation and incorporate non-UI processes.</span></span> <span data-ttu-id="d4c8e-273">以單一處理程式顯示 GUI 的任何應用程式，都會受到此緩解措施的影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-273">Any application that displays a GUI using a single process will be impacted by this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-274">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-274">Configuration options</span></span>

<span data-ttu-id="d4c8e-275">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-275">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-276">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-276">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="do-not-allow-child-processes"></a><span data-ttu-id="d4c8e-277">不允許子流程</span><span class="sxs-lookup"><span data-stu-id="d4c8e-277">Do not allow child processes</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-278">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-278">Description</span></span>

<span data-ttu-id="d4c8e-279">這種緩解可防止應用程式建立新的子應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-279">This mitigation prevents an application from creating new child applications.</span></span> <span data-ttu-id="d4c8e-280">敵人使用的常見技術是在具有惡意)  (輸入的裝置上啟動受信任的程式，這會在裝置上啟動另一個應用程式，這通常需要在裝置上啟動另一個應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-280">A common technique used by adversaries is to initiate a trusted process on the device with malicious input (a "living off the land" attack), which often requires launching another application on the device.</span></span> <span data-ttu-id="d4c8e-281">若應用程式啟動子流程沒有正當原因，此緩解可能會緩解潛在的攻擊媒介。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-281">If there are no legitimate reasons why an application would launch a child process, this mitigation mitigates that potential attack vector.</span></span> <span data-ttu-id="d4c8e-282">會透過設定處理權杖的屬性來套用緩解，這會封鎖使用錯誤訊息 STATUS_CHILD_PROCESS_BLOCKED 的子進程建立權杖。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-282">The mitigation is applied by setting a property on the process token, which blocks creating a token for the child process with the error message STATUS_CHILD_PROCESS_BLOCKED.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-283">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-283">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-284">如果您的應用程式因任何原因而啟動子應用程式，例如支援可啟動瀏覽器或外部瀏覽器的超連結，或是在電腦上啟動其他公用程式，則此功能會在套用此緩解措施時遭到破壞。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-284">If your application launches child applications for any reason, such as supporting hyperlinks that launch a browser or an external browser, or which launch other utilities on the computer, this functionality will be broken with this mitigation applied.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-285">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-285">Configuration options</span></span>

<span data-ttu-id="d4c8e-286">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-286">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-287">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-287">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="export-address-filtering"></a><span data-ttu-id="d4c8e-288">匯出位址篩選</span><span class="sxs-lookup"><span data-stu-id="d4c8e-288">Export address filtering</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-289">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-289">Description</span></span>

<span data-ttu-id="d4c8e-290">Export address 篩選 (EAF) 緩解惡意程式碼的風險查看所有載入模組的匯出位址資料表，以尋找包含其攻擊有用之實用 APIs 的模組。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-290">Export address filtering (EAF) mitigates the risk of malicious code looking at the export address table of all loaded modules to find modules that contain useful APIs for their attack.</span></span> <span data-ttu-id="d4c8e-291">這是外殼程式使用的常見戰術。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-291">This is a common tactic used by shellcode.</span></span> <span data-ttu-id="d4c8e-292">為了緩解這類攻擊的風險，此項緩解功能會保護三個常見的攻擊模組：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-292">In order to mitigate the risk of such an attack, this mitigation protects three commonly attacked modules:</span></span>

- <span data-ttu-id="d4c8e-293">ntdll.dll</span><span class="sxs-lookup"><span data-stu-id="d4c8e-293">ntdll.dll</span></span>
- <span data-ttu-id="d4c8e-294">kernelbase.dll</span><span class="sxs-lookup"><span data-stu-id="d4c8e-294">kernelbase.dll</span></span>
- <span data-ttu-id="d4c8e-295">kernel32.dll</span><span class="sxs-lookup"><span data-stu-id="d4c8e-295">kernel32.dll</span></span>

<span data-ttu-id="d4c8e-296">緩解措施會保護 [匯出目錄] 中的 [記憶體] 頁面，指向 [ [匯出位址] 表格](https://docs.microsoft.com/windows/win32/debug/pe-format#export-address-table)。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-296">The mitigation protects the memory page in the [export directory that points to the [export address table](https://docs.microsoft.com/windows/win32/debug/pe-format#export-address-table).</span></span> <span data-ttu-id="d4c8e-297">此記憶體頁面會套用 [PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) 保護。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-297">This memory page will have the [PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) protection applied to it.</span></span> <span data-ttu-id="d4c8e-298">當有人嘗試存取這種記憶體時，它會產生 STATUS_GUARD_PAGE_VIOLATION。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-298">When someone tries to access this memory, it will generate a STATUS_GUARD_PAGE_VIOLATION.</span></span> <span data-ttu-id="d4c8e-299">「緩解」會處理此例外狀況，如果訪問指令未通過驗證，將會終止處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-299">The mitigation handles this exception, and if the accessing instruction doesn't pass validation, the process will be terminated.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-300">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-300">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-301">這種緩解主要是針對像是偵錯工具、沙箱化應用程式、使用 DRM 的應用程式，或執行反調試技術的應用程式所引發的問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-301">This mitigation is primarily an issue for applications such as debuggers, sandboxed applications, applications using DRM, or applications that implement anti-debugging technology.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-302">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-302">Configuration options</span></span>

<span data-ttu-id="d4c8e-303">**驗證一般濫用之模組的存取權** -此選項又稱為 EAF +，為其他經常攻擊的模組新增保護：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-303">**Validate access for modules that are commonly abused by exploits** - This option, also known as EAF+, adds protections for other commonly attacked modules:</span></span>

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

<span data-ttu-id="d4c8e-304">此外，透過啟用 EAF +，此緩解措施會在包含 "MZ" 標頭的頁面上加入 PAGE_GUARD 保護，在 [PE 檔案中加入 DOS 標](https://docs.microsoft.com/windows/win32/debug/pe-format#ms-dos-stub-image-only)頭的前兩個位元組，也就是外殼程式可以尋找以找出記憶體可能感興趣之模組的另一個方面。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-304">Additionally, by enabling EAF+, this mitigation adds the PAGE_GUARD protection to the page containing the "MZ" header, the first two bytes of the [DOS header in a PE file](https://docs.microsoft.com/windows/win32/debug/pe-format#ms-dos-stub-image-only), which is another aspect of known memory content which shellcode can look for to identify modules potentially of interest in memory.</span></span>

<span data-ttu-id="d4c8e-305">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-305">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-306">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-306">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="force-randomization-for-images-mandatory-aslr"></a><span data-ttu-id="d4c8e-307"> (強制的 ASLR 中強制執行影像的隨機化) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-307">Force randomization for images (Mandatory ASLR)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-308">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-308">Description</span></span>

<span data-ttu-id="d4c8e-309">Address Space Layout (ASLR) 緩解攻擊者使用系統記憶體配置知識的風險，以執行已存在於進程記憶體中，且已標示為可執行檔程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-309">Address Space Layout Randomization (ASLR) mitigates the risk of an attacker using their knowledge of the memory layout of the system in order to execute code that is already present in process memory and already marked as executable.</span></span> <span data-ttu-id="d4c8e-310">這可減少攻擊者使用 libc 攻擊等技術所面臨的風險，其中的入侵者會設定內容，然後修改傳回位址，以符合敵人目的內容的內容來執行現有的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-310">This can mitigate the risk of an attacker using techniques such as return-to-libc attacks, where the adversary sets the context and then modifies the return address to execute existing code with context that suits the adversary's purpose.</span></span>

<span data-ttu-id="d4c8e-311">強制 ASLR 會強制處理常式內所有 Dll 的變基。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-311">Mandatory ASLR forces a rebase of all DLLs within the process.</span></span> <span data-ttu-id="d4c8e-312">開發人員可以使用 [/DYNAMICBASE](https://docs.microsoft.com/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) 連結器選項來啟用 ASLR，而且此緩解作用會相同。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-312">A developer can enable ASLR using the [/DYNAMICBASE](https://docs.microsoft.com/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=vs-2019&preserve-view=true) linker option, and this mitigation has the same effect.</span></span>

<span data-ttu-id="d4c8e-313">當記憶體管理員在圖像中對應至程式時，強制的 ASLR 會強制變基 Dll 和 Exe 未選擇進行 ASLR。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-313">When the memory manager is mapping in the image into the process, Mandatory ASLR will forcibly rebase DLLs and EXEs that have not opted in to ASLR.</span></span> <span data-ttu-id="d4c8e-314">不過，請注意，此重定沒有熵，因此可置於記憶體的可預測位置。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-314">Note, however, that this rebasing has no entropy, and can therefore be placed at a predictable location in memory.</span></span> <span data-ttu-id="d4c8e-315">針對二進位檔的 rebased 與隨機位置，此緩解應該成對 [記憶體分配 (自下而上的 ASLR) ](#randomize-memory-allocations-bottom-up-aslr)。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-315">For rebased and randomized location of binaries, this mitigation should be paired with [Randomize memory allocations (Bottom-up ASLR)](#randomize-memory-allocations-bottom-up-aslr).</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-316">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-316">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-317">ASLR 的相容性影響通常會限制為舊版的應用程式，這些應用程式是使用編譯器對二進位檔案基底位址進行的假設，或已去掉基底位置資訊。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-317">This compatibility impact of ASLR is typically constrained to older applications that were built using compilers that made assumptions about the base address of a binary file or have stripped out base relocation information.</span></span> <span data-ttu-id="d4c8e-318">這可能會造成無法預期的錯誤，因為執行流程會嘗試跳至預期（而非實際）記憶體中的位置。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-318">This can lead to unpredictable errors as the execution flow attempts to jump to the expected, rather than the actual, location in memory.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-319">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-319">Configuration options</span></span>

<span data-ttu-id="d4c8e-320">**不允許去除的影像** -此選項會封鎖已去掉重新安置位置資訊之影像的載入。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-320">**Do not allow stripped images** - This option blocks the loading of images that have had relocation information stripped.</span></span> <span data-ttu-id="d4c8e-321">Windows PE 檔案格式包含絕對位址，此外，編譯器也會產生 [基底重新置放表，以供載入程式用來找出所有的相對記憶體參考及其位移，所以如果二進位檔案未在其慣用的基底位址載入，便可進行更新。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-321">The Windows PE file format contains absolute addresses, and the compiler also generates a [base relocation table that the loader can use to find all relative memory references and their offset, so they can be updated if the binary does not load at its preferred base address.</span></span> <span data-ttu-id="d4c8e-322">有些舊版的應用程式會在實際執行內部版本中找出這項資訊，因此無法 rebased 這些二進位檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-322">Some older applications strip out this information in production builds, and therefore these binaries cannot be rebased.</span></span> <span data-ttu-id="d4c8e-323">這種緩解的情況會封鎖此類二進位檔案 (，而不是讓它們在其慣用的基底位址) 載入。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-323">This mitigation blocks such binaries from being loaded (instead of allowing them to load at their preferred base address).</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-324">**強制隨機化 (必要的 ASLR)** 沒有稽核模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-324">**Force randomization for images (Mandatory ASLR)** has no audit mode.</span></span>

## <a name="import-address-filtering-iaf"></a><span data-ttu-id="d4c8e-325">匯入位址篩選 (IAF) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-325">Import address filtering (IAF)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-326">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-326">Description</span></span>

<span data-ttu-id="d4c8e-327">[匯入位址] 篩選 (IAF) 緩解方法，可協助您降低發生隱患的風險，方法是修改匯入位址資料表 (IAT) ，以在呼叫該函數時重新導向任意攻擊者選擇的任意程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-327">The import address filtering (IAF) mitigation helps mitigate the risk of an adversary changing the control flow of an application by modifying the import address table (IAT) to redirect to arbitrary code of the attacker's choice when that function is called.</span></span> <span data-ttu-id="d4c8e-328">攻擊者可使用此方法來劫持控制，或截取、檢查和攔截敏感 APIs 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-328">An attacker could use this approach to hijack control, or to intercept, inspect, and potentially block calls to sensitive APIs.</span></span>

<span data-ttu-id="d4c8e-329">所有受保護 APIs 的記憶體頁面會套用 [PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) 保護。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-329">The memory pages for all protected APIs will have the [PAGE_GUARD](https://docs.microsoft.com/windows/win32/memory/creating-guard-pages) protection applied to them.</span></span> <span data-ttu-id="d4c8e-330">當有人嘗試存取這種記憶體時，它會產生 STATUS_GUARD_PAGE_VIOLATION。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-330">When someone tries to access this memory, it will generate a STATUS_GUARD_PAGE_VIOLATION.</span></span> <span data-ttu-id="d4c8e-331">「緩解」會處理此例外狀況，如果訪問指令未通過驗證，將會終止處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-331">The mitigation handles this exception, and if the accessing instruction doesn't pass validation, the process will be terminated.</span></span>

<span data-ttu-id="d4c8e-332">此項緩解可保護下列 Windows APIs：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-332">This mitigation protects the following Windows APIs:</span></span>

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-333">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-333">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-334">執行 API 截取的合法應用程式可能會在此緩解措施中偵測到，並造成部分應用程式損毀。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-334">Legitimate applications that perform API interception may be detected by this mitigation and cause some applications to crash.</span></span> <span data-ttu-id="d4c8e-335">範例包括安全性軟體和應用程式相容性填充程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-335">Examples include security software and application compatibility shims.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-336">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-336">Configuration options</span></span>

<span data-ttu-id="d4c8e-337">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-337">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-338">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-338">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="randomize-memory-allocations-bottom-up-aslr"></a><span data-ttu-id="d4c8e-339">在 (自下而上的 ASLR) 隨機化記憶體分配</span><span class="sxs-lookup"><span data-stu-id="d4c8e-339">Randomize memory allocations (Bottom-up ASLR)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-340">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-340">Description</span></span>

<span data-ttu-id="d4c8e-341">隨機記憶體分配 (自下而上的 ASLR) 新增熵以重設位置，因此其位置是隨機的，因此可預測性較低。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-341">Randomize memory allocations (Bottom-up ASLR) adds entropy to relocations, so their location is randomized and therefore less predictable.</span></span> <span data-ttu-id="d4c8e-342">這種緩解需要必要的 ASLR 才會生效。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-342">This mitigation requires Mandatory ASLR to take effect.</span></span>

<span data-ttu-id="d4c8e-343">32位位址空間的大小會將實際限制放在可以新增的熵上，因此，64位應用程式可讓攻擊者更難於猜測記憶體中的位置。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-343">The size of the 32-bit address space places practical constraints on the entropy that can be added, and therefore 64-bit applications make it more difficult for an attacker to guess a location in memory.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-344">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-344">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-345">大多數與必要 ASLR 相容的應用程式 (重定) 也相容其他的平均熵（自下而上的 ASLR）。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-345">Most applications that are compatible with Mandatory ASLR (rebasing) are also compatible with the other entropy of Bottom-up ASLR.</span></span> <span data-ttu-id="d4c8e-346">當某些應用程式在32位變數中儲存本機指標時，可能會發生指標截斷問題， (應將其基底位址低於 4 GB) ，因此會與 (可停用) 的高熵選項不相容。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-346">Some applications may have pointer-truncation issues if they are saving local pointers in 32-bit variables (expecting a base address below 4 GB), and thus will be incompatible with the high entropy option (which can be disabled).</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-347">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-347">Configuration options</span></span>

<span data-ttu-id="d4c8e-348">**不使用高熵** -此選項會停用高熵 ASLR，這會將24位的平均資訊量 (1 TB 的變化) 併入64位應用程式的自下而上的分攤。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-348">**Don't use high entropy** - this option disables the use of high-entropy ASLR, which adds 24 bits of entropy (1 TB of variance) into the bottom-up allocation for 64-bit applications.</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-349">**隨機記憶體分配 (自下而上的 ASLR)** 沒有稽核模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-349">**Randomize memory allocations (Bottom-up ASLR)** has no audit mode.</span></span>

## <a name="simulate-execution-simexec"></a><span data-ttu-id="d4c8e-350">模擬執行 (SimExec) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-350">Simulate execution (SimExec)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-351">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-351">Description</span></span>

<span data-ttu-id="d4c8e-352">模擬執行 (SimExec) 只會緩解32位應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-352">Simulate execution (SimExec) is a mitigation for 32-bit applications only.</span></span> <span data-ttu-id="d4c8e-353">這有助於驗證敏感 APIs 的呼叫是否會傳回合法的呼叫者功能。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-353">This helps validate that calls to sensitive APIs will return to legitimate caller functions.</span></span> <span data-ttu-id="d4c8e-354">方法是將來電攔截成敏感的 APIs，然後透過已編碼的組合語言指示尋找 RET 指令（該指令應該會傳回來電者）來模擬執行的 APIs。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-354">It does this by intercepting calls into sensitive APIs, and then simulating the execution of those APIs by walking through the encoded assembly language instructions looking for the RET instruction, which should return to the caller.</span></span> <span data-ttu-id="d4c8e-355">然後，它會檢查該函數並在記憶體中向下走，以尋找前面的呼叫指示，以判斷函數和呼叫指示是否相符，以及該 RET 是否尚未截獲。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-355">It then inspects that function and walks backwards in memory to find the preceding CALL instruction to determine whether the function and CALL instruction match, and that the RET hasn't been intercepted.</span></span>

<span data-ttu-id="d4c8e-356">由此緩解所截獲的 APIs 包括：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-356">The APIs intercepted by this mitigation are:</span></span>

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

<span data-ttu-id="d4c8e-357">如果偵測到 ROP 小工具，將會終止處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-357">If a ROP gadget is detected, the process is terminated.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-358">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-358">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-359">執行 API 截取的應用程式（特別是安全性軟體）可能會造成此緩解的相容性問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-359">Applications that perform API interception, particularly security software, can cause compatibility problems with this mitigation.</span></span>

<span data-ttu-id="d4c8e-360">這種緩解方式與任意代碼保護的緩解不相容。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-360">This mitigation is incompatible with the Arbitrary Code Guard mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-361">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-361">Configuration options</span></span>

<span data-ttu-id="d4c8e-362">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-362">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-363">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-363">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="validate-api-invocation-callercheck"></a><span data-ttu-id="d4c8e-364">驗證 API 呼叫 (CallerCheck) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-364">Validate API invocation (CallerCheck)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-365">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-365">Description</span></span>

<span data-ttu-id="d4c8e-366">驗證 API 呼叫 (CallerCheck) 是針對傳回導向的程式設計所做的緩解 (ROP) 的技術，以驗證是否從有效的來電者呼叫敏感的 APIs。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-366">Validate API invocation (CallerCheck) is a mitigation for return-oriented programming (ROP) techniques that validates that sensitive APIs were called from a valid caller.</span></span> <span data-ttu-id="d4c8e-367">此項緩解檢查傳遞的傳回位址，然後 heuristically 向後反彙編以尋找位於傳回位址上方的呼叫，以判斷呼叫目標是否符合傳遞到該功能的參數。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-367">This mitigation inspects the passed return address, and then heuristically disassembles backwards to find a call above the return address to determine if the call target matches the parameter passed into the function.</span></span>

<span data-ttu-id="d4c8e-368">由此緩解所截獲的 APIs 包括：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-368">The APIs intercepted by this mitigation are:</span></span>

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

<span data-ttu-id="d4c8e-369">如果偵測到 ROP 小工具，將會終止處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-369">If a ROP gadget is detected, the process is terminated.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-370">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-370">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-371">執行 API 截取的應用程式（特別是安全性軟體）可能會造成此緩解的相容性問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-371">Applications that perform API interception, particularly security software, can cause compatibility problems with this mitigation.</span></span>

<span data-ttu-id="d4c8e-372">這種緩解方式與任意代碼保護的緩解不相容。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-372">This mitigation is incompatible with the Arbitrary Code Guard mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-373">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-373">Configuration options</span></span>

<span data-ttu-id="d4c8e-374">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-374">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-375">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-375">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="validate-exception-chains-sehop"></a><span data-ttu-id="d4c8e-376">驗證例外鏈 (SEHOP) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-376">Validate exception chains (SEHOP)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-377">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-377">Description</span></span>

<span data-ttu-id="d4c8e-378">驗證例外鏈 (SEHOP) 會針對 *結構化的例外狀況處理常式進行緩解， (SEH) 覆寫* 利用技術。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-378">Validate exception chains (SEHOP) is a mitigation against the *Structured Exception Handler (SEH) overwrite* exploitation technique.</span></span> <span data-ttu-id="d4c8e-379">[結構化的例外狀況處理](https://docs.microsoft.com/windows/win32/debug/structured-exception-handling) 程式是應用程式可要求處理特定例外狀況的程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-379">[Structured exception handling](https://docs.microsoft.com/windows/win32/debug/structured-exception-handling) is the process by which an application can ask to handle a particular exception.</span></span> <span data-ttu-id="d4c8e-380">例外狀況處理常式會連結在一起，因此，如果一個例外狀況處理常式選擇不處理特定的例外狀況，則可以將它傳遞至鏈中的下一個例外狀況處理常式，直到一個決定處理該處理常式為止。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-380">Exception handlers are chained together, so that if one exception handler chooses not to handle a particular exception, it can be passed on to the next exception handler in the chain until one decides to handle it.</span></span> <span data-ttu-id="d4c8e-381">因為處理常式的清單是動態的，所以它會儲存在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-381">Because the list of handler is dynamic, it is stored on the stack.</span></span> <span data-ttu-id="d4c8e-382">攻擊者可以利用堆疊溢位漏洞，以指向攻擊者選擇之程式碼的指標覆寫例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-382">An attacker can use a stack overflow vulnerability to then overwrite the exception handler with a pointer to the code of the attacker's choice.</span></span>

<span data-ttu-id="d4c8e-383">此項緩解依賴于 SEH 的設計，其中每個 SEH 專案都包含指向例外狀況處理常式的指標，以及例外狀況鏈中下一個處理常式的指標。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-383">This mitigation relies on the design of SEH, where each SEH entry contains both a pointer to the exception handler, as well as a pointer to the next handler in the exception chain.</span></span> <span data-ttu-id="d4c8e-384">這種緩解是由例外狀況發送器所呼叫，當調用例外狀況時會驗證 SEH 鏈。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-384">This mitigation is called by the exception dispatcher, which validates the SEH chain when an exception is invoked.</span></span> <span data-ttu-id="d4c8e-385">它會驗證：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-385">It verifies that:</span></span>

- <span data-ttu-id="d4c8e-386">所有例外鏈記錄都位於堆疊界限內</span><span class="sxs-lookup"><span data-stu-id="d4c8e-386">All exception chain records are within the stack boundaries</span></span>
- <span data-ttu-id="d4c8e-387">所有例外狀況記錄對齊</span><span class="sxs-lookup"><span data-stu-id="d4c8e-387">All exception records are aligned</span></span>
- <span data-ttu-id="d4c8e-388">沒有例外狀況指標指向堆疊</span><span class="sxs-lookup"><span data-stu-id="d4c8e-388">No exception handler pointers are pointing to the stack</span></span>
- <span data-ttu-id="d4c8e-389">沒有反向指標</span><span class="sxs-lookup"><span data-stu-id="d4c8e-389">There are no backward pointers</span></span>
- <span data-ttu-id="d4c8e-390">例外狀況鏈結束于已知的最後一個例外狀況處理常式</span><span class="sxs-lookup"><span data-stu-id="d4c8e-390">The exception chain ends at a known final exception handler</span></span>

<span data-ttu-id="d4c8e-391">如果這些驗證失敗，則會中止例外狀況處理，而且不會處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-391">If these validations fail, then exception handling is aborted, and the exception will not be handled.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-392">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-392">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-393">SEHOP 的相容性問題相對很少見。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-393">Compatibility issues with SEHOP are relatively rare.</span></span> <span data-ttu-id="d4c8e-394">應用程式對例外狀況鏈的破壞造成的依賴性很少見。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-394">It's uncommon for an application to take a dependency on corrupting the exception chain.</span></span> <span data-ttu-id="d4c8e-395">不過，某些應用程式會受到細微變化的影響，這可能會表現為競爭條件，以顯示應用程式中潛在的多執行緒 bug。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-395">However, some applications are impacted by the subtle changes in timing, which may manifest as a race condition that reveals a latent multi-threading bug in the application.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-396">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-396">Configuration options</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-397">**驗證例外鏈 (SEHOP)** 沒有稽核模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-397">**Validate exception chains (SEHOP)** has no audit mode.</span></span>

## <a name="validate-handle-usage"></a><span data-ttu-id="d4c8e-398">驗證控制碼使用狀況</span><span class="sxs-lookup"><span data-stu-id="d4c8e-398">Validate handle usage</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-399">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-399">Description</span></span>

<span data-ttu-id="d4c8e-400">[*驗證控制碼使用狀況*] 是一種緩解措施，可協助防範攻擊者使用現有的控制碼來存取受保護的物件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-400">*Validate handle usage* is a mitigation that helps protect against an attacker using an existing handle to access a protected object.</span></span> <span data-ttu-id="d4c8e-401">[控點](https://docs.microsoft.com/windows/win32/sysinfo/handles-and-objects)是受保護物件的參照。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-401">A [handle](https://docs.microsoft.com/windows/win32/sysinfo/handles-and-objects) is a reference to a protected object.</span></span> <span data-ttu-id="d4c8e-402">如果應用程式程式碼參照的是不正確控點，這可能表示敵人企圖使用先前錄製的控點 (但哪些應用程式參照計數不會察覺) 。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-402">If application code is referencing an invalid handle, that could indicate that an adversary is attempting to use a handle it has previously recorded (but which application reference counting wouldn't be aware of).</span></span> <span data-ttu-id="d4c8e-403">如果應用程式嘗試使用不正確物件，而不只是傳回 null，則應用程式會引發例外狀況 (STATUS_INVALID_HANDLE) 。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-403">If the application attempts to use an invalid object, instead of simply returning null, the application will raise an exception (STATUS_INVALID_HANDLE).</span></span>

<span data-ttu-id="d4c8e-404">這種緩解功能會自動套用至 Windows Store 應用程式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-404">This mitigation is automatically applied to Windows Store applications.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-405">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-405">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-406">未正確追蹤控點參照的應用程式，以及在例外狀況處理常式中未封裝這些作業的應用程式可能會受到此項緩解的影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-406">Applications that were not accurately tracking handle references, and which were not wrapping these operations in exception handlers, will potentially be impacted by this mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-407">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-407">Configuration options</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-408">**驗證控制碼使用狀況** 沒有稽核模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-408">**Validate handle usage** has no audit mode.</span></span>

## <a name="validate-heap-integrity"></a><span data-ttu-id="d4c8e-409">驗證堆完整性</span><span class="sxs-lookup"><span data-stu-id="d4c8e-409">Validate heap integrity</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-410">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-410">Description</span></span>

<span data-ttu-id="d4c8e-411">「 *驗證堆完整性* 緩解」會隨著偵測到堆損毀而終止應用程式，進而增加 Windows 中堆遷移的保護層級。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-411">The *validate heap integrity* mitigation increases the protection level of heap mitigations in Windows, by causing the application to terminate if a heap corruption is detected.</span></span> <span data-ttu-id="d4c8e-412">緩解措施包括：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-412">The mitigations include:</span></span>

- <span data-ttu-id="d4c8e-413">防止堆控點被釋放</span><span class="sxs-lookup"><span data-stu-id="d4c8e-413">Preventing a HEAP handle from being freed</span></span>
- <span data-ttu-id="d4c8e-414">針對堆分配對擴充區塊標頭執行另一個驗證</span><span class="sxs-lookup"><span data-stu-id="d4c8e-414">Performing another validation on extended block headers for heap allocations</span></span>
- <span data-ttu-id="d4c8e-415">驗證堆集尚未標示為已使用中</span><span class="sxs-lookup"><span data-stu-id="d4c8e-415">Verifying that heap allocations are not already flagged as in-use</span></span>
- <span data-ttu-id="d4c8e-416">將保護頁面新增至大型分配、堆段和 subsegments，其大小高於最小值</span><span class="sxs-lookup"><span data-stu-id="d4c8e-416">Adding guard pages to large allocations, heap segments, and subsegments above a minimum size</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-417">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-417">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-418">針對64位應用程式，以及以 Windows Vista 或更新版本為目標的32位應用程式而言，此緩解措施已被預設套用。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-418">This mitigation is already applied by default for 64-bit applications and for 32-bit applications targeting Windows Vista or later.</span></span> <span data-ttu-id="d4c8e-419">Windows XP 或更早版本中的繼承應用程式最有風險，但較少的相容性問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-419">Legacy applications from Windows XP or earlier are most at-risk, though compatibility issues are rare.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-420">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-420">Configuration options</span></span>

> [!Note]
> <span data-ttu-id="d4c8e-421">**驗證堆完整性** 沒有任何審計模式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-421">**Validate heap integrity** has no audit mode.</span></span>

## <a name="validate-image-dependency-integrity"></a><span data-ttu-id="d4c8e-422">驗證映射相依性完整性</span><span class="sxs-lookup"><span data-stu-id="d4c8e-422">Validate image dependency integrity</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-423">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-423">Description</span></span>

<span data-ttu-id="d4c8e-424">*驗證映射依賴性* 緩解可協助防範企圖取代以 Windows 二進位檔案靜態連結之 dll 之程式碼的攻擊。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-424">The *validate image dependency* mitigation helps protect against attacks that attempt to substitute code for dlls that are statically linked by Windows binaries.</span></span> <span data-ttu-id="d4c8e-425">DLL 植入的技術會濫用載入程式的搜尋機制，以注入惡意程式碼，可用來取得在提升許可權的內容中執行的惡意程式碼。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-425">The technique of DLL planting abuses the loader's search mechanism to inject malicious code, which can be used to get malicious code running in an elevated context.</span></span> <span data-ttu-id="d4c8e-426">當載入器載入 Windows 簽署的二進位檔案，然後載入二進位檔案所依據的任何 dll 時，將會驗證這些二進位檔案，以確保它們也是以數位方式簽署為 Windows 二進位檔案。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-426">When the loader is loading a Windows signed binary, and then loads up any dlls that the binary depends on, these binaries will be verified to ensure that they are also digitally signed as a Windows binary.</span></span> <span data-ttu-id="d4c8e-427">若失敗簽章檢查，將不會載入 dll，而且會引發例外狀況，傳回 STATUS_INVALID_IMAGE_HASH 的狀態。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-427">If they fail the signature check, the dll will not be loaded, and will throw an exception, returning a status of STATUS_INVALID_IMAGE_HASH.</span></span>

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-428">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-428">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-429">相容性問題並不常見。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-429">Compatibility issues are uncommon.</span></span> <span data-ttu-id="d4c8e-430">取決於以本機私人版本取代 Windows 二進位檔案的應用程式會受到影響，而且在多執行緒應用程式中也會出現細微的計時錯誤。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-430">Applications that depend on replacing Windows binaries with local private versions will be impacted, and there is also a small risk of revealing subtle timing bugs in multi-threaded applications.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-431">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-431">Configuration options</span></span>

<span data-ttu-id="d4c8e-432">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-432">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-433">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-433">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

## <a name="validate-stack-integrity-stackpivot"></a><span data-ttu-id="d4c8e-434">驗證堆疊整體性 (StackPivot) </span><span class="sxs-lookup"><span data-stu-id="d4c8e-434">Validate stack integrity (StackPivot)</span></span>

### <a name="description"></a><span data-ttu-id="d4c8e-435">描述</span><span class="sxs-lookup"><span data-stu-id="d4c8e-435">Description</span></span>

<span data-ttu-id="d4c8e-436">「 *驗證堆疊完整性」 (StackPivot)* 緩解，可協助防範堆疊資料攻擊、攻擊者在堆記憶體中建立虛假堆疊的 ROP 攻擊，然後讓應用程式傳回偽堆疊，以控制執行流程。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-436">The *validate stack integrity (StackPivot)* mitigation helps protect against the Stack Pivot attack, a ROP attack where an attacker creates a fake stack in heap memory, and then tricks the application into returning into the fake stack that controls the flow of execution.</span></span>

<span data-ttu-id="d4c8e-437">此項緩解會截獲許多 Windows APIs，並檢查堆疊指標的值。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-437">This mitigation intercepts many Windows APIs, and inspects the value of the stack pointer.</span></span> <span data-ttu-id="d4c8e-438">如果堆疊指標的位址不在堆疊的底部和頂端之間，則會記錄事件，如果不是在審計模式，則會終止處理常式。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-438">If the address of the stack pointer does not fall between the bottom and the top of the stack, then an event is recorded and, if not in audit mode, the process will be terminated.</span></span>

<span data-ttu-id="d4c8e-439">由此緩解所截獲的 APIs 包括：</span><span class="sxs-lookup"><span data-stu-id="d4c8e-439">The APIs intercepted by this mitigation are:</span></span>

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a><span data-ttu-id="d4c8e-440">相容性考慮</span><span class="sxs-lookup"><span data-stu-id="d4c8e-440">Compatibility considerations</span></span>

<span data-ttu-id="d4c8e-441">使用偽堆疊的應用程式會受到影響，而且在多執行緒應用程式中也會造成細微計時錯誤的小危險。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-441">Applications that are using fake stacks will be impacted, and there is also a small risk of revealing subtle timing bugs in multi-threaded applications.</span></span>
<span data-ttu-id="d4c8e-442">執行 API 截取的應用程式（特別是安全性軟體）可能會造成此緩解的相容性問題。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-442">Applications that perform API interception, particularly security software, can cause compatibility problems with this mitigation.</span></span>

<span data-ttu-id="d4c8e-443">這種緩解方式與任意代碼保護的緩解不相容。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-443">This mitigation is incompatible with the Arbitrary Code Guard mitigation.</span></span>

### <a name="configuration-options"></a><span data-ttu-id="d4c8e-444">設定選項</span><span class="sxs-lookup"><span data-stu-id="d4c8e-444">Configuration options</span></span>

<span data-ttu-id="d4c8e-445">**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-445">**Audit Only** - You can enable this mitigation in audit mode in order to measure the potential compatibility impact on an application.</span></span> <span data-ttu-id="d4c8e-446">然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。</span><span class="sxs-lookup"><span data-stu-id="d4c8e-446">Audit events can then be viewed either in the event viewer or using Advanced Hunting in [Microsoft Defender for Endpoint](https://docs.microsoft.com/microsoft-365/security/defender/advanced-hunting-overview).</span></span>

---
title: 探索保護參考
keywords: 緩和措施, 弱點, 弱點, 緩和措施, 惡意探索, 惡意探索, emet
description: 有關 exploit protection 功能在 Windows 10 中運作方式的詳細資訊
search.product: eADQiWindows 10XVcnh
ms.pagetype: security
ms.prod: m365-security
ms.mktglfcycl: manage
ms.sitesec: library
localization_priority: Normal
audience: ITPro
author: denisebmsft
ms.author: deniseb
ms.date: 01/06/2021
ms.reviewer: cjacks
manager: dansimp
ms.custom: asr
ms.technology: mde
ms.topic: article
ms.openlocfilehash: b8d1abcc7f204b2d393729bc63b7b2b3ab53fbbd
ms.sourcegitcommit: 4886457c0d4248407bddec56425dba50bb60d9c4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/03/2021
ms.locfileid: "53290182"
---
# <a name="exploit-protection-reference"></a>Exploit Protection 參考

[!INCLUDE [Microsoft 365 Defender rebranding](../../includes/microsoft-defender.md)]


**適用於：**
- [適用於端點的 Microsoft Defender](https://go.microsoft.com/fwlink/?linkid=2154037)
- [Microsoft 365 Defender](https://go.microsoft.com/fwlink/?linkid=2118804)

>想要體驗適用於端點的 Microsoft Defender 嗎？ [注册免費試用版。](https://www.microsoft.com/microsoft-365/windows/microsoft-defender-atp?ocid=docs-wdatp-enablesiem-abovefoldlink)

Exploit protection 為 IT Pro 可以套用的應用程式提供高級保護，以供開發人員編譯及散佈軟體之後套用。

本文可協助您瞭解如何在原則層級和個別的緩解原則上進行 exploit protection 的運作，以協助您成功建立及套用 Exploit Protection 原則。

## <a name="how-mitigations-are-applied"></a>如何套用緩解

每個應用程式都會套用 Exploit Protection 緩解。

針對您為其設定保護的每個程式，透過登錄專案設定緩解。 這些設定儲存在每個程式 (的 **MitigationOptions** 登錄專案中 **HKEY_LOCAL_MACHINE \ 軟體 \ Microsoft \ Windows NT \ CurrentVersion \ Image File *ImageFileName* \ MitigationOptions**) 。 它們會在您重新開機程式時生效，而且在您變更並重新啟動程式之前仍然有效。

> [!IMPORTANT]
> Image File 執行選項僅允許您指定檔案名或路徑，而不是版本號碼、架構或任何其他特異點。 請務必將遷移目標設定為具有唯一名稱或路徑的應用程式，只在您已測試該版本的裝置及該應用程式的架構上加以套用。

如果您使用 XML 設定檔（不論是透過 PowerShell、群組原則或 MDM）設定 exploit protection 緩解，請在處理此 XML 設定檔時，為您設定個別的登錄設定。

當您不再強制發佈 XML 檔案時，不會自動移除由此 XML 設定檔部署的設定。 若要移除 Exploit Protection 設定，請從清潔 Windows 10 裝置匯出 XML 設定，然後部署這個新的 XML 檔案。 另外，Microsoft 也會提供 XML 檔案，作為重設 Exploit Protection 設定之 Windows 安全性基準的一部分。

若要使用 PowerShell 重設 exploit protection 設定，您可以使用下列命令：

```powershell
Set-ProcessMitigation -PolicyFilePath EP-reset.xml
```
以下是隨 Windows 安全性基線一起發佈的 EP-reset.xml：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<MitigationPolicy>
  <AppConfig Executable="ONEDRIVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR OverrideRelocateImages="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
  </AppConfig>
  <AppConfig Executable="firefox.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
  </AppConfig>
  <AppConfig Executable="fltldr.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="GROOVE.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
    <ImageLoad OverrideBlockRemoteImages="false" />
    <ChildProcess OverrideChildProcess="false" />
  </AppConfig>
  <AppConfig Executable="Acrobat.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="AcroRd32.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="chrome.exe">
    <DEP OverrideDEP="false" />
  </AppConfig>
  <AppConfig Executable="EXCEL.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="iexplore.exe">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="INFOPATH.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="java.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaw.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="javaws.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="LYNC.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSACCESS.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="MSPUB.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OIS.EXE">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="OUTLOOK.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="plugin-container.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="POWERPNT.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="PPTVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VISIO.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="VPREVIEW.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="WINWORD.EXE">
    <DEP OverrideDEP="false" />
    <ASLR ForceRelocateImages="true" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wmplayer.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
  <AppConfig Executable="wordpad.exe">
    <DEP OverrideDEP="false" />
    <Payload OverrideEnableExportAddressFilter="false" OverrideEnableExportAddressFilterPlus="false" OverrideEnableImportAddressFilter="false" OverrideEnableRopStackPivot="false" OverrideEnableRopCallerCheck="false" OverrideEnableRopSimExec="false" />
  </AppConfig>
</MitigationPolicy>
```

## <a name="mitigation-reference"></a>緩解參照

下列各節將詳細說明每項 exploit protection 緩解措施所提供的保護、緩解的相容性考慮，以及可用的設定選項。

## <a name="arbitrary-code-guard"></a>任意代碼保護

### <a name="description"></a>說明

任意代碼保護措施可協助防範惡意攻擊者，透過記憶體安全弱點將其選擇的程式碼載入到記憶體中，並能夠執行該程式碼。

任意代碼保護會保護應用程式無法執行動態產生的程式碼 (未載入的程式碼，例如從 exe 本身或 dll) 。 使用任何程式碼 guard，都可以避免將記憶體標示為可執行。 當應用程式嘗試 [分配記憶體](/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc)時，我們會檢查保護旗標。  (記憶體可使用讀取、寫入和/或執行保護旗標進行指派。 ) 如果分配嘗試包含 [*執行*](/windows/win32/memory/memory-protection-constants) 保護旗標，則記憶體分配會失敗，並傳回錯誤碼 (STATUS_DYNAMIC_CODE_BLOCKED) 。 同樣地，如果應用程式嘗試變更已分配的 [記憶體保護旗標](/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect) ，並包含 [*執行*](/windows/win32/memory/memory-protection-constants) 保護旗標，則許可權變更會失敗並傳回錯誤碼 (STATUS_DYNAMIC_CODE_BLOCKED) 。

透過避免設定 [執行] 旗標，Windows 10 的資料執行防護功能就可以防範設定為該記憶體的指令指標，並 *執行* 該程式碼。

### <a name="compatibility-considerations"></a>相容性考慮

任意代碼保護可防止將任何記憶體當做可執行檔方式來分配，這會帶來即時 (JIT) 編譯器等方法的相容性問題。 例如，大多數新式瀏覽器都會將 JavaScript 編譯成原生程式碼，以優化效能。 為了支援此項緩解，您需要 rearchitected 以在受保護的程式外移動 JIT 編譯。 其他應用程式，其設計可從腳本或其他中間語言產生程式碼會類似于此緩解。

### <a name="configuration-options"></a>設定選項

**允許執行緒自願** 使用-您可以設定緩解，以允許個別執行緒自願退出這項保護。 開發人員必須已編寫應用程式，且已將 *ThreadInformation* 參數設定為 **ThreadDynamicCodePolicy** ， [](/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadinformation)才能允許在此執行緒上執行動態程式碼。

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後可以在事件檢視器中查看或使用 [Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="block-low-integrity-images"></a>封鎖低完整性映像

### <a name="description"></a>說明

封鎖低誠信影像可防止應用程式載入不受信任的檔案，通常是因為這些檔案已從沙箱瀏覽器從網際網路下載。

如果此圖像有 (ACE) 會授與低 IL 處理常式的存取權，且沒有信任標籤 ACE，則此緩解會封鎖圖像載入。 它是由記憶體管理員所實施，它會封鎖檔案不會被對應至記憶體。 如果應用程式嘗試對應低完整性影像，它會觸發 STATUS_ACCESS_DENIED 錯誤。 如需完整性層級運作方式的詳細資訊，請參閱 [必要的完整性控制](/windows/win32/secauthz/mandatory-integrity-control)。

### <a name="compatibility-considerations"></a>相容性考慮

封鎖低誠信影像會使應用程式無法載入從網際網路下載的檔案。 如果您的應用程式工作流程需要載入已下載的影像，您會想要確保從較高信任的程式下載，或明確重新標記它們，以便套用此項緩解。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="block-remote-images"></a>封鎖遠端映像

### <a name="description"></a>說明

封鎖遠端映射有助於防止應用程式載入遠端裝置上主控的檔案，例如 UNC 共用。 封鎖遠端映射可協助防止將二進位檔案載入到攻擊者所控制的外部裝置的記憶體中。

如果將影像決定在遠端裝置上，此緩解會封鎖圖像載入。 它是由記憶體管理員所實施，它會封鎖檔案不會被對應至記憶體。 如果應用程式嘗試對應遠端檔案，則會觸發 STATUS_ACCESS_DENIED 錯誤。

### <a name="compatibility-considerations"></a>相容性考慮

封鎖遠端映射會使應用程式無法從遠端裝置載入影像。 如果您的應用程式從遠端裝置載入檔案或外掛程式，它將不會與此項緩解相容。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="block-untrusted-fonts"></a>封鎖不信任的字型

### <a name="description"></a>說明

封鎖不受信任的字型可降低因導致攻擊者能夠在裝置上執行程式碼的字型剖析中的缺陷風險。 只會載入安裝在 windows\fonts 目錄中的字體，以供 GDI 處理。

這項緩解是在 GDI 中實施，這會驗證檔案的位置。 如果檔案不在系統字型目錄中，則不會載入字型以進行剖析，而且此呼叫會失敗。

此項緩解不僅除了 Windows 10 1607 和更新版本中提供的內建緩解，也會將字體分析移出內核，並移至使用者模式應用程式容器。 以字體分析為基礎的任何利用方式，都是在沙箱化且隔離的內容中進行，這樣會大幅降低風險。 如需此緩解功能的詳細資訊，請參閱博客[強化 Windows 10 和零日利用方式緩解](https://www.microsoft.com/security/blog/2017/01/13/hardening-windows-10-with-zero-day-exploit-mitigations/)。

### <a name="compatibility-considerations"></a>相容性考慮

在 [系統字體] 目錄外，最常用的字型是使用 [web](/typography/fonts/font-faq#web)字型。 新式瀏覽器（例如 Microsoft Edge）會使用 DirectWrite，而不是 GDI，而且不會受到影響。 不過，舊版瀏覽器（例如 [新增) Microsoft Edge 中的 Internet Explorer 11 (和 IE 模式）可能會受到影響，尤其是 Office 365 等應用程式（使用字型字型來顯示 UI）。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="code-integrity-guard"></a>程式碼完整性防護

### <a name="description"></a>說明

程式碼完整性保護可確保所有載入到程式中的二進位檔案都由 Microsoft 進行數位簽章。 程式碼整體性防護包括[whql](/windows-hardware/drivers/install/whql-release-signature) (Windows 硬體品質實驗室) 特徵碼，這會允許在程式中執行 whql 核准的驅動程式。

這種緩解是在記憶體管理員內實施，這會封鎖二進位數以對應至記憶體。 如果您嘗試載入的二進位檔案未由 Microsoft 簽署，記憶體管理器將會傳回錯誤 STATUS_INVALID_IMAGE_HASH。 透過在記憶體管理員層級封鎖，可防止處理常式和二進位檔案所載入的二進位檔案都被插入處理常式。

### <a name="compatibility-considerations"></a>相容性考慮

這種緩解特別會封鎖未由 Microsoft 簽署的任何二進位檔案。 如此一來，它會與大多數協力廠商軟體不相容，除非軟體是透過) Microsoft Store 來 (和進行數位簽署的方式發佈，而且會選取允許載入由 Microsoft Store 所簽署之影像的選項。

### <a name="configuration-options"></a>設定選項

**此外，允許載入** 由 Microsoft Store 所發行的 Microsoft Store 應用程式所簽署的影像，將會以 Microsoft Store 進行數位簽署，新增此設定將允許應用程式載入已透過 Store 認證程式進行的二進位檔案。

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="control-flow-guard-cfg"></a>控制流量防護 (CFG) 

### <a name="description"></a>說明

控制流量防護 (CFG) 會保護間接的函數呼叫，以降低攻擊者使用記憶體損毀漏洞的風險。 例如，攻擊者可能會使用緩衝區溢位弱點覆寫包含函數指標的記憶體，並以指標取代該函數指標，其選擇的可執行程式碼也 (，也就是插入程式) 中。

在編譯時間插入另一個檢查即可提供此緩解。 在每個間接功能呼叫之前，新增另一個指示，以確認目標是有效的呼叫目標，再呼叫它。 若目標不是有效的呼叫目標，則應用程式會終止。 如此一來，只有以 CFG 所支援的應用程式，才能受益于此緩解。

有效目標的檢查是由 Windows 內核所提供。 當載入可執行檔時，間接呼叫目標的中繼資料會在載入時解壓縮，並標示為有效的呼叫目標。 此外，記憶體的指派及標示為可執行檔 (例如，針對產生的程式碼) ，這些記憶體位置也會標示為有效的呼叫目標，以支援 JIT 編譯等機制。

### <a name="compatibility-considerations"></a>相容性考慮

因為應用程式必須編譯以支援 CFG，所以它們會以隱含方式宣告其相容性。 因此，大多數的應用程式都應該在啟用此緩解的情況下運作。 因為這些檢查會編譯成二進位，您可以套用的設定只是在 Windows 內核內停用檢查。 換句話說，依預設會開啟緩解，但您可以將 Windows 內核設定為在您後來判斷應用程式開發人員在其測試中未發現的相容性問題（應該很少見）時，永遠傳回「是」。

### <a name="configuration-options"></a>設定選項

**使用 strict CFG** -在嚴格模式中，必須編譯載入到程式中的所有二進位檔案，以進行控制項 Flow Guard (或沒有任何可執行程式碼（例如資源 dll) 才能載入）。

> [!Note]
> **控制流量防護** 沒有任何審計模式。 二進位檔案會在啟用此緩解功能時進行編譯。

## <a name="data-execution-prevention-dep"></a>資料執行防護 (DEP)

### <a name="description"></a>說明

資料執行防護 (DEP) 會防止未明確指派成可執行檔記憶體執行。 DEP 可協助防範攻擊者將惡意程式碼注入程式中，例如透過緩衝區溢位，然後執行該程式碼。

如果您嘗試將指令指標設定為未標示為可執行檔記憶體位址，處理器會引發例外狀況 (一般保護違例) ，導致應用程式當機。

### <a name="compatibility-considerations"></a>相容性考慮

所有 x64、ARM 及 ARM-64 可執行檔預設都會啟用 DEP，而且無法停用。 因為應用程式永遠不會執行 DEP，所以會採用相容性。

所有 x86 (32 位) 二進位檔案預設都會啟用 DEP，但可對每個進程停用 DEP。 一些舊的繼承應用程式，通常是在 Windows XP SP2 之前所開發的應用程式，可能無法與 DEP 相容。 這類應用程式通常會以動態方式產生程式碼 (例如，JIT 編譯) 或連結到舊的文件庫 (例如，) 可動態產生程式碼的舊版 ATL。

### <a name="configuration-options"></a>設定選項

**啟用 Atl Thunk 模擬** -此設定選項會停用 ATL Thunk 模擬。 ATL （ActiveX 範本庫）的設計方式，都是盡可能快又快。 為了降低二進位大小，它會使用稱為 *Thunking* 的技術。 Thunking 通常會考慮在32位和16位的應用程式之間進行互動，但沒有任何16位的元件可以在 ATL 上進行。 相反地，為了針對二進位大小進行優化，ATL 會將機器碼儲存在非文字對齊 (的記憶體中，以建立較小的二進位) ，然後直接叫用該程式碼。 編譯成 Visual Studio 7.1 或更早版本 (Visual Studio 2003) 的 ATL 元件，請勿將此記憶體指派為可執行檔 Thunk 模擬以解決該相容性問題。 具有二進位擴充模型 (的應用程式（例如 Internet Explorer 11) ）通常必須啟用 ATL Thunk 模擬。

## <a name="disable-extension-points"></a>停用擴充點

### <a name="description"></a>說明

此項緩解會停用應用程式的各種擴充點，可用來建立持久性或提升惡意內容的許可權。

這包括：

- **AppInit dll** -每當處理常式啟動時，系統會將指定的 DLL 載入到新啟動程式的內容中，再呼叫其進入點函數。 您[可以在這裡找到 AppInit dll 的詳細資料](/windows/win32/winmsg/about-window-classes#application-global-classes)。 套用此緩解原則時，不會載入 AppInit Dll。 從 Windows 7 開始，AppInit dll 必須以數位方式簽署，[如以下所述](/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2)。 此外，從 Windows 8 開始，如果啟用 SecureBoot，將不會載入 AppInit dll （[如這裡所述](/windows/win32/dlls/secure-boot-and-appinit-dlls)）。
- **舊版** 輸入法-輸入法編輯器 (輸入法) 可讓使用者輸入的文字的語言超過可以在鍵盤上呈現的字元數。 協力廠商可以建立 Ime。 惡意的輸入法可能會取得來自此輸入捕獲的認證或其他敏感資訊。 有些 ime （稱為舊版 ime）只會在 Windows 桌面應用程式，而不是 UWP 應用程式上運作。 這種緩解也會使舊版的 IME 無法載入至指定的 Windows 桌面應用程式。
- **Windows 事件掛接**-應用程式可呼叫 [SetWinEventHook API](/windows/win32/api/winuser/nf-winuser-setwineventhook) ，以在發生事件時註冊利益。 會指定 DLL，並可將其注入程式中。 此項減輕會強制將掛接傳送至註冊程式，而不是透過插入的 DLL 在進程內執行。

### <a name="compatibility-considerations"></a>相容性考慮

大部分的延伸點都相對較少使用，所以相容性影響通常很小，尤其是在個別應用層級。 考慮的是，如果使用者使用協力廠商的舊版 Ime，將無法與受保護的應用程式搭配使用。

### <a name="configuration-options"></a>設定選項

此項緩解沒有任何設定選項。

> [!Note]
> **停用分機點** 沒有審計模式。

## <a name="disable-win32k-system-calls"></a>停用 Win32k 系統呼叫

### <a name="description"></a>說明

Win32k.sys 提供攻擊者廣泛的攻擊面。 做為核心模式元件時，它通常會以沙箱化應用程式的轉義向量為目標。 這種緩解功能會封鎖執行緒，以防止呼叫 win32k.sys，其方式是封鎖執行緒，以將其自身轉換成 GUI 執行緒，然後就可以存取權調用 Win32k 函數。 在建立時，執行緒是非 GUI，但會在第一次呼叫 win32k.sys 時，或透過 API 對 [IsGuiThread](/windows/win32/api/winuser/nf-winuser-isguithread)進行轉換。

### <a name="compatibility-considerations"></a>相容性考慮

這種緩解方式是針對專用非 UI 進程的處理常式而設計。 例如，許多新式瀏覽器都會使用進程隔離，並併入非 UI 進程。 以單一處理程式顯示 GUI 的任何應用程式，都會受到此緩解措施的影響。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="do-not-allow-child-processes"></a>不允許子處理序

### <a name="description"></a>說明

這種緩解可防止應用程式建立新的子應用程式。 敵人使用的常見技術是在具有惡意)  (輸入的裝置上啟動受信任的程式，這會在裝置上啟動另一個應用程式，這通常需要在裝置上啟動另一個應用程式。 若應用程式啟動子流程沒有正當原因，此緩解可能會緩解潛在的攻擊媒介。 會透過設定處理權杖的屬性來套用緩解，這會封鎖使用錯誤訊息 STATUS_CHILD_PROCESS_BLOCKED 的子進程建立權杖。

### <a name="compatibility-considerations"></a>相容性考慮

如果您的應用程式因任何原因而啟動子應用程式，例如支援可啟動瀏覽器或外部瀏覽器的超連結，或是在電腦上啟動其他公用程式，則此功能會在套用此緩解措施時遭到破壞。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="export-address-filtering"></a>匯出位址篩選

### <a name="description"></a>說明

Export address 篩選 (EAF) 緩解惡意程式碼的風險查看所有載入模組的匯出位址資料表，以尋找包含其攻擊有用之實用 APIs 的模組。 這是外殼程式使用的常見戰術。 為了緩解這類攻擊的風險，此項緩解功能會保護三個常見的攻擊模組：

- ntdll.dll
- kernelbase.dll
- kernel32.dll

緩解措施會保護 [匯出目錄] 中的 [記憶體] 頁面，指向 [ [匯出位址] 表格](/windows/win32/debug/pe-format#export-address-table)。 此記憶體頁面會套用 [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) 保護。 當有人嘗試存取這種記憶體時，它會產生 STATUS_GUARD_PAGE_VIOLATION。 「緩解」會處理此例外狀況，如果訪問指令未通過驗證，將會終止處理常式。

### <a name="compatibility-considerations"></a>相容性考慮

這種緩解主要是針對像是偵錯工具、沙箱化應用程式、使用 DRM 的應用程式，或執行反調試技術的應用程式所引發的問題。

### <a name="configuration-options"></a>設定選項

**驗證一般濫用之模組的存取權** -此選項又稱為 EAF +，為其他經常攻擊的模組新增保護：

- `mshtml.dll`
- `flash*.ocx`
- `jscript*.ocx`
- `vbscript.dll`
- `vgx.dll`
- `mozjs.dll`
- `xul.dll`
- `acrord32.dll`
- `acrofx32.dll`
- `acroform.api`

此外，透過啟用 EAF +，此緩解措施會在包含 "MZ" 標頭的頁面上加入 PAGE_GUARD 保護，在 [PE 檔案中加入 DOS 標](/windows/win32/debug/pe-format#ms-dos-stub-image-only)頭的前兩個位元組，也就是外殼程式可以尋找以找出記憶體可能感興趣之模組的另一個方面。

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="force-randomization-for-images-mandatory-aslr"></a>強制執行映像隨機化 (強制 ASLR)

### <a name="description"></a>說明

Address Space Layout (ASLR) 緩解攻擊者使用系統記憶體配置知識的風險，以執行已存在於進程記憶體中，且已標示為可執行檔程式碼。 這可減少攻擊者使用 libc 攻擊等技術所面臨的風險，其中的入侵者會設定內容，然後修改傳回位址，以符合敵人目的內容的內容來執行現有的程式碼。

強制 ASLR 會強制處理常式內所有 Dll 的變基。 開發人員可以使用 [/DYNAMICBASE](/cpp/build/reference/dynamicbase-use-address-space-layout-randomization) 連結器選項來啟用 ASLR，而且此緩解作用會相同。

當記憶體管理員在圖像中對應至程式時，強制的 ASLR 會強制變基 Dll 和 Exe 未選擇進行 ASLR。 不過，請注意，此重定沒有熵，因此可置於記憶體的可預測位置。 針對二進位檔的 rebased 與隨機位置，此緩解應該成對 [記憶體分配 (自下而上的 ASLR) ](#randomize-memory-allocations-bottom-up-aslr)。

### <a name="compatibility-considerations"></a>相容性考慮

ASLR 的相容性影響通常會限制為舊版的應用程式，這些應用程式是使用編譯器對二進位檔案基底位址進行的假設，或已去掉基底位置資訊。 這可能會造成無法預期的錯誤，因為執行流程會嘗試跳至預期（而非實際）記憶體中的位置。

### <a name="configuration-options"></a>設定選項

**不允許去除的影像** -此選項會封鎖已去掉重新安置位置資訊之影像的載入。 Windows PE 檔案格式包含絕對位址，而編譯器也會產生 [基底重新置放表，讓載入器用來找出所有的相對記憶體參考及其位移，這樣一來，如果二進位檔案不是以其慣用的基底位址載入，便可以進行更新。 有些舊版的應用程式會在實際執行內部版本中找出這項資訊，因此無法 rebased 這些二進位檔案。 這種緩解的情況會封鎖此類二進位檔案 (，而不是讓它們在其慣用的基底位址) 載入。

> [!Note]
> **強制隨機化 (必要的 ASLR)** 沒有稽核模式。

## <a name="import-address-filtering-iaf"></a>匯入位址篩選 (IAF)

### <a name="description"></a>說明

[匯入位址] 篩選 (IAF) 緩解方法，可協助您降低發生隱患的風險，方法是修改匯入位址資料表 (IAT) ，以在呼叫該函數時重新導向任意攻擊者選擇的任意程式碼。 攻擊者可使用此方法來劫持控制，或截取、檢查和攔截敏感 APIs 的呼叫。

所有受保護 APIs 的記憶體頁面會套用 [PAGE_GUARD](/windows/win32/memory/creating-guard-pages) 保護。 當有人嘗試存取這種記憶體時，它會產生 STATUS_GUARD_PAGE_VIOLATION。 「緩解」會處理此例外狀況，如果訪問指令未通過驗證，將會終止處理常式。

此項緩解措施會保護下列 Windows APIs：

- `GetProcAddress`
- `GetProcAddressForCaller`
- `LoadLibraryA`
- `LoadLibraryExA`
- `LoadLibraryW`
- `LoadLibraryExW`
- `LdrGetProcedureAddress`
- `LdrGetProcedureAddressEx`
- `LdrGetProcedureAddressForCaller`
- `LdrLoadDll`
- `VirtualProtect`
- `VirtualProtectEx`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `NtProtectVirtualMemory`
- `CreateProcessA`
- `CreateProcessW`
- `WinExec`
- `CreateProcessAsUserA`
- `CreateProcessAsUserW`
- `GetModuleHandleA`
- `GetModuleHandleW`
- `RtlDecodePointer`
- `DecodePointer`

### <a name="compatibility-considerations"></a>相容性考慮

執行 API 截取的合法應用程式可能會在此緩解措施中偵測到，並造成部分應用程式損毀。 範例包括安全性軟體和應用程式相容性填充程式。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="randomize-memory-allocations-bottom-up-aslr"></a>在 (自下而上的 ASLR) 隨機化記憶體分配

### <a name="description"></a>說明

隨機記憶體分配 (自下而上的 ASLR) 新增熵以重設位置，因此其位置是隨機的，因此可預測性較低。 這種緩解需要必要的 ASLR 才會生效。

32位位址空間的大小會將實際限制放在可以新增的熵上，因此，64位應用程式可讓攻擊者更難於猜測記憶體中的位置。

### <a name="compatibility-considerations"></a>相容性考慮

大多數與必要 ASLR 相容的應用程式 (重定) 也相容其他的平均熵（自下而上的 ASLR）。 當某些應用程式在32位變數中儲存本機指標時，可能會發生指標截斷問題， (應將其基底位址低於 4 GB) ，因此會與 (可停用) 的高熵選項不相容。

### <a name="configuration-options"></a>設定選項

**不使用高熵** -此選項會停用高熵 ASLR，這會將24位的平均資訊量 (1 TB 的變化) 併入64位應用程式的自下而上的分攤。

> [!Note]
> **隨機記憶體分配 (自下而上的 ASLR)** 沒有稽核模式。

## <a name="simulate-execution-simexec"></a>模擬執行 (SimExec)

### <a name="description"></a>說明

模擬執行 (SimExec) 只會緩解32位應用程式。 這有助於驗證敏感 APIs 的呼叫是否會傳回合法的呼叫者功能。 方法是將來電攔截成敏感的 APIs，然後透過已編碼的組合語言指示尋找 RET 指令（該指令應該會傳回來電者）來模擬執行的 APIs。 然後，它會檢查該函數並在記憶體中向下走，以尋找前面的呼叫指示，以判斷函數和呼叫指示是否相符，以及該 RET 是否尚未截獲。

由此緩解所截獲的 APIs 包括：

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

如果偵測到 ROP 小工具，將會終止處理常式。

### <a name="compatibility-considerations"></a>相容性考慮

執行 API 截取的應用程式（特別是安全性軟體）可能會造成此緩解的相容性問題。

這種緩解方式與任意代碼保護的緩解不相容。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="validate-api-invocation-callercheck"></a>驗證 API 引動過程 (CallerCheck)

### <a name="description"></a>說明

驗證 API 呼叫 (CallerCheck) 是針對傳回導向的程式設計所做的緩解 (ROP) 的技術，以驗證是否從有效的來電者呼叫敏感的 APIs。 此項緩解檢查傳遞的傳回位址，然後 heuristically 向後反彙編以尋找位於傳回位址上方的呼叫，以判斷呼叫目標是否符合傳遞到該功能的參數。

由此緩解所截獲的 APIs 包括：

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

如果偵測到 ROP 小工具，將會終止處理常式。

### <a name="compatibility-considerations"></a>相容性考慮

執行 API 截取的應用程式（特別是安全性軟體）可能會造成此緩解的相容性問題。

這種緩解方式與任意代碼保護的緩解不相容。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="validate-exception-chains-sehop"></a>驗證例外狀況鏈結 (SEHOP)

### <a name="description"></a>說明

驗證例外鏈 (SEHOP) 會針對 *結構化的例外狀況處理常式進行緩解， (SEH) 覆寫* 利用技術。 [結構化的例外狀況處理](/windows/win32/debug/structured-exception-handling) 程式是應用程式可要求處理特定例外狀況的程式。 例外狀況處理常式會連結在一起，因此，如果一個例外狀況處理常式選擇不處理特定的例外狀況，則可以將它傳遞至鏈中的下一個例外狀況處理常式，直到一個決定處理該處理常式為止。 因為處理常式的清單是動態的，所以它會儲存在堆疊上。 攻擊者可以利用堆疊溢位漏洞，以指向攻擊者選擇之程式碼的指標覆寫例外狀況處理常式。

此項緩解依賴于 SEH 的設計，其中每個 SEH 專案都包含指向例外狀況處理常式的指標，以及例外狀況鏈中下一個處理常式的指標。 這種緩解是由例外狀況發送器所呼叫，當調用例外狀況時會驗證 SEH 鏈。 它會驗證：

- 所有例外鏈記錄都位於堆疊界限內
- 所有例外狀況記錄對齊
- 沒有例外狀況指標指向堆疊
- 沒有反向指標
- 例外狀況鏈結束于已知的最後一個例外狀況處理常式

如果這些驗證失敗，則會中止例外狀況處理，而且不會處理例外狀況。

### <a name="compatibility-considerations"></a>相容性考慮

SEHOP 的相容性問題相對很少見。 應用程式對例外狀況鏈的破壞造成的依賴性很少見。 不過，某些應用程式會受到細微變化的影響，這可能會表現為競爭條件，以顯示應用程式中潛在的多執行緒 bug。

### <a name="configuration-options"></a>設定選項

> [!Note]
> **驗證例外鏈 (SEHOP)** 沒有稽核模式。

## <a name="validate-handle-usage"></a>驗證控制代碼使用方式

### <a name="description"></a>說明

[*驗證控制碼使用狀況*] 是一種緩解措施，可協助防範攻擊者使用現有的控制碼來存取受保護的物件。 [控點](/windows/win32/sysinfo/handles-and-objects)是受保護物件的參照。 如果應用程式程式碼參照的是不正確控點，這可能表示敵人企圖使用先前錄製的控點 (但哪些應用程式參照計數不會察覺) 。 如果應用程式嘗試使用不正確物件，而不只是傳回 null，則應用程式會引發例外狀況 (STATUS_INVALID_HANDLE) 。

這種緩解功能會自動套用至 Windows 儲存應用程式。

### <a name="compatibility-considerations"></a>相容性考慮

未正確追蹤控點參照的應用程式，以及在例外狀況處理常式中未封裝這些作業的應用程式可能會受到此項緩解的影響。

### <a name="configuration-options"></a>設定選項

> [!Note]
> **驗證控制碼使用狀況** 沒有稽核模式。

## <a name="validate-heap-integrity"></a>驗證堆積完整性

### <a name="description"></a>說明

「*驗證堆完整性* 緩解」會隨著偵測到堆損毀，在 Windows 中提升堆遷移的保護層級。 緩解措施包括：

- 防止堆控點被釋放
- 針對堆分配對擴充區塊標頭執行另一個驗證
- 驗證堆集尚未標示為已使用中
- 將保護頁面新增至大型分配、堆段和 subsegments，其大小高於最小值

### <a name="compatibility-considerations"></a>相容性考慮

針對64位應用程式和設定為 Windows Vista 或更新版本的32位應用程式而言，此緩解措施已被預設套用。 Windows XP 或更早版本的繼承應用程式最有風險，但較少的相容性問題。

### <a name="configuration-options"></a>設定選項

> [!Note]
> **驗證堆完整性** 沒有任何審計模式。

## <a name="validate-image-dependency-integrity"></a>驗證映像相依性完整性

### <a name="description"></a>說明

*驗證映射依賴性* 緩解可協助防範企圖取代以靜態方式 Windows 二進位連結之 dll 程式碼的攻擊。 DLL 植入的技術會濫用載入程式的搜尋機制，以注入惡意程式碼，可用來取得在提升許可權的內容中執行的惡意程式碼。 當載入器載入 Windows 已簽署二進位檔案，然後載入二進位檔案所依據的任何 dll 時，將會驗證這些二進位檔案，以確保它們也會以數位方式簽署成 Windows 二進位。 若失敗簽章檢查，將不會載入 dll，而且會引發例外狀況，傳回 STATUS_INVALID_IMAGE_HASH 的狀態。

### <a name="compatibility-considerations"></a>相容性考慮

相容性問題並不常見。 依靠以本機私人版本取代 Windows 二進位檔案的應用程式會受到影響，而且在多執行緒應用程式中也會出現細微的計時錯誤。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。

## <a name="validate-stack-integrity-stackpivot"></a>驗證堆疊完整性 (StackPivot)

### <a name="description"></a>說明

「 *驗證堆疊完整性」 (StackPivot)* 緩解，可協助防範堆疊資料攻擊、攻擊者在堆記憶體中建立虛假堆疊的 ROP 攻擊，然後讓應用程式傳回偽堆疊，以控制執行流程。

此項緩解會截獲許多 Windows APIs，並檢查堆疊指標的值。 如果堆疊指標的位址不在堆疊的底部和頂端之間，則會記錄事件，如果不是在審計模式，則會終止處理常式。

由此緩解所截獲的 APIs 包括：

- `LoadLibraryA`
- `LoadLibraryW`
- `LoadLibraryExA`
- `LoadLibraryExW`
- `LdrLoadDll`
- `VirtualAlloc`
- `VirtualAllocEx`
- `NtAllocateVirtualMemory`
- `VirtualProtect`
- `VirtualProtectEx`
- `NtProtectVirtualMemory`
- `HeapCreate`
- `RtlCreateHeap`
- `CreateProcessA`
- `CreateProcessW`
- `CreateProcessInternalA`
- `CreateProcessInternalW`
- `NtCreateUserProcess`
- `NtCreateProcess`
- `NtCreateProcessEx`
- `CreateRemoteThread`
- `CreateRemoteThreadEx`
- `NtCreateThreadEx`
- `WriteProcessMemory`
- `NtWriteVirtualMemory`
- `WinExec`
- `CreateFileMappingA`
- `CreateFileMappingW`
- `CreateFileMappingNumaW`
- `NtCreateSection`
- `MapViewOfFile`
- `MapViewOfFileEx`
- `MapViewOfFileFromApp`
- `LdrGetProcedureAddressForCaller`

### <a name="compatibility-considerations"></a>相容性考慮

使用偽堆疊的應用程式會受到影響，而且在多執行緒應用程式中也會造成細微計時錯誤的小危險。
執行 API 截取的應用程式（特別是安全性軟體）可能會造成此緩解的相容性問題。

這種緩解方式與任意代碼保護的緩解不相容。

### <a name="configuration-options"></a>設定選項

**僅限審核** -您可以在稽核模式中啟用此項緩解，以度量對應用程式的潛在相容性影響。 然後，您可以在事件檢視器中查看或使用 [Microsoft Defender For Endpoint](/microsoft-365/security/defender/advanced-hunting-overview)中的高級搜尋來查看審核事件。
